---
layout: post
title: "Client Annotation Support"
description: "This tutorial describes how to get annotations on client side"
category: "4. Client"
---

# Background #

Before ODataLib 6.10.0, OData core lib has supported metadata annotations for metadata element in model and instance annotations for a particular instance in payload. But on client side, there isn’t a good way to get these  annotations. So In ODataLib 6.10.0, we provided several APIs to enable user to get annotations on client side. Basically, OData client follows the rules defined in [OData V4.0 protocol](http://docs.oasis-open.org/odata/odata/v4.0/errata02/os/complete/part1-protocol/odata-v4.0-errata02-os-part1-protocol-complete.html) (see [6.4 Vocabulary Extensibility](http://docs.oasis-open.org/odata/odata/v4.0/errata02/os/complete/part1-protocol/odata-v4.0-errata02-os-part1-protocol-complete.html#_Toc406398214)) to get instance annotations or metadata annotations.

# How to get annotations on client side #

All client CLR types in this tutorial are generated by OData Client Code Generator. Before we dive into this tutorial, you can read “[How to use OData Client Code Generator to generate client-side proxy class](https://blogs.msdn.microsoft.com/odatateam/2014/03/11/tutorial-sample-how-to-use-odata-client-code-generator-to-generate-client-side-proxy-class/)” for generating client side proxy class.
OData Client provided following APIs for getting annotations in `DataServiceContext` class. 

OData Client provided following APIs for getting annotations in `DataServiceContext` class.
 
    public bool TryGetAnnotation<TResult>(object source, string term, string qualifier, out TResult annotation) 
    public bool TryGetAnnotation<TResult>(object source, string term, out TResult annotation)
    public bool TryGetAnnotation<TFunc, TResult>(Expression<TFunc> expression, string term, string qualifier, out TResult annotation)
    public bool TryGetAnnotation<TFunc, TResult>(Expression<TFunc> expression, string term, out TResult annotation)

The first two APIs are for getting annotations associated with a specified object. The last two APIs are for getting annotations for a property, a navigation property, an entity set, a singleton, an operation or an operation import.

In these APIs, *term* is the full qualified name of term, *qualifier* should be provided if an annotation contains qualifier, which means, if the annotation defines qualifier, but user use null as qualifier, then these APIs will return false.

In following part, we will give some examples for what we have supported in ODataLib 6.10.0. But for other elements that we didn’t mentioned, they haven’t been supported yet. 

## Request preference odata.include-annotations ##

To get instance annotations, we need to set odata.include-annotations preference in request to specify the set of annotations the client requests to be included.

    public static void Main(string[] args)
    {
        DefaultContainer dsc = new DefaultContainer(new Uri("http://services.odata.org/V4/(S(uvf1y321yx031rnxmcbqmlxw))/TripPinServiceRW/"));
        dsc.SendingRequest2 += (sender, eventArgs) =>
        {
            eventArgs.RequestMessage.SetHeader("Prefer", "odata.include-annotations=\"*\"");
        };
    }

Please refer to [8.2.8.4 Preference odata.include-annotations](http://docs.oasis-open.org/odata/odata/v4.0/errata02/os/complete/part1-protocol/odata-v4.0-errata02-os-part1-protocol-complete.html#_Toc406398237) for the rules of this preference.

## Get annotations Code Sample ##

### Get an instance annotation for a feed ###

    var personQueryResponse = dsc.People.Execute();
    personQueryResponse.ToList();
    dsc.TryGetAnnotation(personQueryResponse, fullQualifiedTermName, null /*qualifier*/, out annotation);

Please note the first parameter should be an `QueryOperationResponse<Person\>`.

For feed, we have to enumerate the response to materialize the annotation. So in this code block, we call `personQueryResponse.ToList()` to enumerate the response, and then we call `public bool TryGetAnnotation<TResult>(object source, string term, string qualifier, out TResult annotation)` to get the instance annotations for the
 feed.

Currently, qualifier is not supported for instance annotation. So we pass in null for qualifier parameter. Also, we  can use `public bool TryGetAnnotation<TResult>(object source, string term, out TResult annotation)` which doesn't contain qualifier parameter.

Please note, if you want to get a metadata annotation for an entity set, you should use the last two APIs, which will be mentioned later.
 
### Get an annotation for an entity ###

    var person = dsc.People.ByKey("russellwhyte").GetValue();
    bool result = dsc.TryGetAnnotation(person, fullQualifiedTermName, qualifier, out annotation);

Please note the first parameter should be the Clr object. This API will firstly try to get the instance annotation of the `fullQualifiedTermName` and `qualifier`. If the instance annotation doesn't exist, it will try to get the metadata annotation of the `fullQualifiedTermName` and `qualifier`. 

### Get an annotation for a property in an entity or a navigation property###

    var person = dsc.People.ByKey("russellwhyte").GetValue();

    // Try to get an annotation for a property
    dsc.TryGetAnnotation<Func<ObservableCollection<string>>, string>(() => person.Emails, fullQualifiedTermName, qualifier, out annotation);

    // Try to get an annotation for a navigation property
    dsc.TryGetAnnotation<Func<Photo>, string>(() => person.Photo, fullQualifiedTermName, qualifier, out annotation);

The first parameter is the closure lambda expression which is to access the property. The API will firstly try to get the instance annotation, if it doesn't exist, it will try to get the metadata annotation for the property.

### Get annotation for a complex value ###

    var address = dsc.People.ByKey("russellwhyte").Select(p => p.AddressInfo).GetValue();
    dsc.TryGetAnnotation(address, fullQualifiedTermName, qualifier, out annotation);


The first parameter is the Clr instance of a complex type. This API will firstly try to get the instance annotation of this complex value, if it doesn't exit, it will try to get the metadata annotation for the complex type of the instance.

### Get metadata annotation for an entity set/singleton/function/function import/action/action import  ###

In section "Get an instance annotation for a feed", we know that to get metadata annotation for an entity set, we should use the last two APIs. This rule is also apply to singleton, function, function import, action and action import.

    // Try to get a metadata annotation for an entity set
    dsc.TryGetAnnotation<Func<DataServiceQuery<Person>>, string>(() => dsc.People, fullQualifiedTermName, qualifier, out annotation);
 
    // Try to get a metadata annotation for a singleton
    dsc.TryGetAnnotation<Func<PersonSingle>, string>(()=>dsc.Me, fullQualifiedTermName, qualifier, out annotation);
    
    // Try to get a metadata annotation for a function bound to a person
    var person = dsc.People.ByKey("russellwhyte").GetValue();
    dsc.TryGetAnnotation<Func<AirlineSingle>, string>(()=>person.GetFavoriteAirline(),  fullQualifiedTermName, qualifier, out annotation);

    // Try to get a metadata annotaiton for an action bound to a person
    dsc.TryGetAnnotation<Func<string, int, DataServiceActionQuery>, string>((userName, tripId) => person.ShareTrip(userName, tripId), fullQualifiedTermName, qualifier, out annotation);

    // Try to get a metadata annotation for a function import
    dsc.TryGetAnnotation<Func<double, double, AirportSingle>, string>((lat, lon) => dsc.GetNearestAirport(lat, lon), fullQualifiedTermName, qualifier, out annotation);

    // Try to get a metadata annotation for an action import
    dsc.TryGetAnnotation<Func<DataServiceActionQuery>, string>(() => dsc.ResetDataSource(), fullQualifiedTermName, qualifier, out annotation);

