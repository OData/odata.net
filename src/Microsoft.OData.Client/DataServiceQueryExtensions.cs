//---------------------------------------------------------------------
// <copyright file="DataServiceQueryOfT.cs" company="Microsoft">
//      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------

namespace Microsoft.OData.Client
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Expressions;

    using Microsoft.Spatial;

    /// <summary>
    /// Extension methods for <see cref="DataServiceQuery{TElement}"/>
    /// </summary>
    /// <remarks>
    /// We discussed three options when we decided to implement extension methods for <see cref="DataServiceQuery{TElement}"/> that are analogous to the LINQ extensions
    /// for <see cref="IQueryable{T}"/>, but that preserve the <see cref="DataServiceQuery{T}"/> type. They were:
    /// 1. Implement an ExecuteBatch overload on <see cref="DataServiceContext"/> that would take <see cref="IQueryable{T}"/>s as parameters
    /// 2. Implement a Query extension method that would preserve the <see cref="DataServiceQuery{TElement}"/> type and take in the <see cref="IQueryable{T}"/> query
    /// that should be applied to the <see cref="DataServiceQuery{TElement}"/>, something like:
    /// public static DataServiceQuery&gt;TResult> Query<&gt;TElement, TResult>(
    ///     this DataServiceQuery&gt;TElement> source, 
    ///     Func&gt;IQueryable&gt;TElement>, IQueryable&gt;TResult>> query)
    /// {
    ///     return new DataServiceQuery&gt;TResult>(query(source).Expression, new DataServiceQueryProvider(source.Context));
    /// }
    /// 3. Implement the analogous extension methods as we have done
    /// 
    /// Option 1 has the benefit of being closer to what current callers are doing. Most callers call <see cref="DataServiceContext.CreateQuery{T}(string)"/> and then
    /// pass the resulting <see cref="DataServiceQuery{TElement}"/>s as parameters to <see cref="DataServiceContext.ExecuteBatch(DataServiceRequest[])"/>. In this way,
    /// they would follow the same pattern, but if the caller uses a LINQ query on some number of the returned <see cref="DataServiceQuery{TElement}"/>s, their code
    /// would simply automatically call the new overload for the ExecuteBatch method.
    /// 
    /// Option 2 has the benefit from the development side that there is a single method that needs to be implemented, and it would support all of the LINQ queries.
    /// 
    /// Option 3 has the benefit, like option 1, that it is completely transparent to the caller, and it also allows us to preserve the
    /// <see cref="DataServiceQuery{TElement}"/> type for other cases outside of <see cref="DataServiceContext.ExecuteBatch(DataServiceRequest[])"/>
    /// 
    /// We ruled out option 2 because we decided it was important for the solution to be discoverable. There is already a solution to this issue in the
    /// <see cref="DataServiceQuery{TElement}.AddQueryOption(string, object)"/> AddQueryOption method, so having an additional solution that callers won't find was not
    /// desirable.
    /// 
    /// We ruled out option 1 because type checks are another reason that callers don't like to use
    /// <see cref="DataServiceQuery{TElement}.AddQueryOption(string, object)"/>. <see cref="DataServiceQuery{TElement}.AddQueryOption(string, object)"/> removes the
    /// typing from the <see cref="IQueryable{T}"/>. Option 1 would also strip out the typing. To preserve the type, there would need to be multiple overloads with
    /// different number of type parameters, like:
    /// public static DataServiceResponse ExecuteBatch<T1>(IQueryable<T1> query1)
    /// {
    ///     ...
    /// }
    /// 
    /// public static DataServiceResponse ExecuteBatch&gt;T1, T2>(IQueryable&gt;T1> query1, IQueryable&gt;T2> query2)
    /// {
    ///     ...
    /// }
    /// 
    /// ...
    /// Even if we ignore the typing issue, the new overload would also assume that the <see cref="IQueryable{T}"/>s that it receives were generated by the same
    /// <see cref="IQueryProvider"/> that the <see cref="DataServiceContext"/> uses. We would have to do this validation at runtime, and errors here would be unintuitive
    /// for the caller. 
    /// 
    /// Since options 3 preserves the type checks, is highly discoverable by callers, and maintains the current call pattern, we decided it was the best approach.
    /// </remarks>
    public static class DataServiceQueryExtensions
    {
        /// <summary>
        /// Concatenates two sequences.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="source1">The first sequence to concatenate.</param>
        /// <param name="source2">The sequence to concatenate to the first sequence.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains the concatenated elements of the two input sequences.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source1"/> or <paramref name="source2"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Concat<TSource>(this DataServiceQuery<TSource> source1, IEnumerable<TSource> source2)
        {
            return new DataServiceQuery<TSource>(source1.AsQueryable().Concat(source2).Expression, new DataServiceQueryProvider(source1.Context));
        }

        /// <summary>
        /// Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">The <see cref="DataServiceQuery{TElement}"/> to return the specified value for if empty.</param>
        /// <param name="defaultValue">The value to return if the sequence is empty.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains <paramref name="defaultValue"/> if <paramref name="source"/> is empty; otherwise, 
        /// <paramref name="source"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> DefaultIfEmpty<TSource>(this DataServiceQuery<TSource> source, TSource defaultValue)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().DefaultIfEmpty(defaultValue).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">The <see cref="DataServiceQuery{TTElement}"/> to return a default value for if empty.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains <see langword="default"/>(<typeparamref name="TSource"/>) if <paramref name="source"/> is empty;
        /// otherwise, <paramref name="source"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> DefaultIfEmpty<TSource>(this DataServiceQuery<TSource> source)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().DefaultIfEmpty().Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Returns distinct elements from a sequence by using a specified <see cref="IEqualityComparer{T}"/> to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">The <see cref="DataServiceQuery{TElement}"/> to remove duplicates from.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to compare values.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains distinct elements from <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="comparer"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Distinct<TSource>(this DataServiceQuery<TSource> source, IEqualityComparer<TSource> comparer)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().Distinct(comparer).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Returns distinct elements from a sequence by using the default equality comparer to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">The <see cref="DataServiceQuery{TElement}"/> to remove duplicates from.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains distinct elements from <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Distinct<TSource>(this DataServiceQuery<TSource> source)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().Distinct().Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Produces the set difference of two sequences by using the default equality comparer to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="source1">A <see cref="DataServiceQuery{TElement}"/> whose elements that are not also in <paramref name="source2"/> will be returned.</param>
        /// <param name="source2">An <see cref="IEnumerable{T}"/> whose elements that also occur in the first sequence will not appear in the returned sequence.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement} "/>that contains the set difference of the two sequences.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source1"/> or <paramref name="source2"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Except<TSource>(this DataServiceQuery<TSource> source1, IEnumerable<TSource> source2)
        {
            return new DataServiceQuery<TSource>(source1.AsQueryable().Except(source2).Expression, new DataServiceQueryProvider(source1.Context));
        }

        /// <summary>
        /// Produces the set difference of two sequences by using the specified <see cref="IEqualityComparer{T}"/> to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="source1">A <see cref="DataServiceQuery{TElement}"/> whose elements that are not also in <paramref name="source2"/> will be returned.</param>
        /// <param name="source2">An <see cref="IEnumerable{T}"/> whose elements that also occur in the first sequence will not appear in the returned sequence.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to compare values.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains the set difference of the two sequences.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source1"/> or <paramref name="source2"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Except<TSource>(
            this DataServiceQuery<TSource> source1,
            IEnumerable<TSource> source2,
            IEqualityComparer<TSource> comparer)
        {
            return new DataServiceQuery<TSource>(source1.AsQueryable().Except(source2, comparer).Expression, new DataServiceQueryProvider(source1.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of
        /// each group are projected by using a specified function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <typeparam name="TElement">The type of the elements in each <see cref="IGrouping{TKey, TElement}"/>.</typeparam>
        /// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <param name="elementSelector">A function to map each source element to an element in an <see cref="IGrouping{TKey, TElement}"/>.</param>
        /// <param name="resultSelector">A function to create a result value from each group.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that has a type argument of <typeparamref name="TResult"/> and where each element represents a projection over a
        /// group and its key.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="elementSelector"/> or <paramref name="resultSelector"/> is
        /// <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> GroupBy<TSource, TKey, TElement, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            Expression<Func<TSource, TElement>> elementSelector,
            Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector)
        {
            return new DataServiceQuery<TResult>(
                source.AsQueryable().GroupBy(keySelector, elementSelector, resultSelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <param name="resultSelector">A function to create a result value from each group.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that has a type argument of <typeparamref name="TResult"/> and where each element represents a projection over a
        /// group and its key.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="resultSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> GroupBy<TSource, TKey, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector)
        {
            return new DataServiceQuery<TResult>(source.AsQueryable().GroupBy(keySelector, resultSelector).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <typeparam name="TElement">The type of the elements in each <see cref="IGrouping{TKey, TElement}"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <param name="elementSelector">A function to map each source element to an element in an <see cref="IGrouping{TKey, TElement}"/>.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> where each element is a <see cref="IGrouping{TKey, TElement}"/> and where each
        /// <see cref="IGrouping{TKey, TElement}"/> contains a sequence of objects of type <typeparamref name="TElement"/> and a key.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="elementSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            Expression<Func<TSource, TElement>> elementSelector)
        {
            return new DataServiceQuery<IGrouping<TKey, TElement>>(
                source.AsQueryable().GroupBy(keySelector, elementSelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Keys are compared by
        /// using a specified comparer and the elements of each group are projected by using a specified function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <typeparam name="TElement">The type of the elements in each <see cref="IGrouping{TKey, TElement}"/>.</typeparam>
        /// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <param name="elementSelector">A function to map each source element to an element in an <see cref="IGrouping{TKey, TElement}"/>.</param>
        /// <param name="resultSelector">A function to create a result value from each group.</param>
        /// <param name="comparer">A <see cref="IEqualityComparer{T}"/> to compare keys.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that has a type argument of <typeparamref name="TResult"/> and where each element represents a projection over a
        /// group and its key.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="elementSelector"/> or <paramref name="resultSelector"/> or
        /// <paramref name="comparer"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> GroupBy<TSource, TKey, TElement, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            Expression<Func<TSource, TElement>> elementSelector,
            Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector,
            IEqualityComparer<TKey> comparer)
        {
            return new DataServiceQuery<TResult>(
                source.AsQueryable().GroupBy(keySelector, elementSelector, resultSelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence according to a specified key selector function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> where each element is a <see cref="IGrouping{TKey, TElement}"/> and where each
        /// <see cref="IGrouping{TKey, TElement}"/> contains a sequence of objects and a key.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="keySelector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector)
        {
            return new DataServiceQuery<IGrouping<TKey, TSource>>(source.AsQueryable().GroupBy(keySelector).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Keys are compared by
        /// using a specified comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <param name="resultSelector">A function to create a result value from each group.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to compare keys.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that has a type argument of <typeparamref name="TResult"/> and where each element represents a projection over a
        /// group and its key.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="resultSelector"/> or <paramref name="comparer"/> is
        /// <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> GroupBy<TSource, TKey, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector,
            IEqualityComparer<TKey> comparer)
        {
            return new DataServiceQuery<TResult>(
                source.AsQueryable().GroupBy(keySelector, resultSelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence and projects the elements for each group by using a specified function. Key values are compared by using a specified
        /// comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <typeparam name="TElement">The type of the elements in each <see cref="IGrouping{TKey, TElement}"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <param name="elementSelector">A function to map each source element to an element in an <see cref="IGrouping{TKey, TElement}"/>.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to compare keys.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> where each element is a <see cref="IGrouping{TKey, TElement}"/> and where each
        /// <see cref="IGrouping{TKey, TElement}"/> contains a sequence of objects of type <typeparamref name="TElement"/> and a key.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="elementSelector"/> or <paramref name="comparer"/> is
        /// <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            Expression<Func<TSource, TElement>> elementSelector,
            IEqualityComparer<TKey> comparer)
        {
            return new DataServiceQuery<IGrouping<TKey, TElement>>(
                source.AsQueryable().GroupBy(keySelector, elementSelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Groups the elements of a sequence according to a specified key selector function and compares the keys by using a specified comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">An <see cref="DataServiceQuery{TElement}"/> whose elements to group.</param>
        /// <param name="keySelector">A function to extract the key for each element.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to compare keys.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> where each element is a <see cref="IGrouping{TKey, TElement}"/> and where each
        /// <see cref="IGrouping{TKey, TElement}"/> contains a sequence of objects and a key.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="comparer"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            IEqualityComparer<TKey> comparer)
        {
            return new DataServiceQuery<IGrouping<TKey, TSource>>(
                source.AsQueryable().GroupBy(keySelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Correlates the elements of two sequences based on key equality and groups the results. A specified <see cref="IEqualityComparer{T}"/> is used to compare
        /// keys.
        /// </summary>
        /// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
        /// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
        /// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
        /// <typeparam name="TResult">The type of the result elements.</typeparam>
        /// <param name="outer">The first sequence to join.</param>
        /// <param name="inner">The sequence to join to the first sequence.</param>
        /// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        /// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        /// <param name="resultSelector">
        /// A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.
        /// </param>
        /// <param name="comparer">A comparer to hash and compare keys.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements of type <typeparamref name="TResult"/> obtained by performing a grouped join on two
        /// sequences.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="outer"/> or <paramref name="inner"/> or <paramref name="outerKeySelector"/> or <paramref name="innerKeySelector"/> or
        /// <paramref name="resultSelector"/> or <paramref name="comparer"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(
            this DataServiceQuery<TOuter> outer,
            IEnumerable<TInner> inner,
            Expression<Func<TOuter, TKey>> outerKeySelector,
            Expression<Func<TInner, TKey>> innerKeySelector,
            Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector,
            IEqualityComparer<TKey> comparer)
        {
            return new DataServiceQuery<TResult>(
                outer.AsQueryable().GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer).Expression,
                new DataServiceQueryProvider(outer.Context));
        }

        /// <summary>
        /// Correlates the elements of two sequences based on key equality and groups the results. The default equality comparer is used to compare keys.
        /// </summary>
        /// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
        /// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
        /// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
        /// <typeparam name="TResult">The type of the result elements.</typeparam>
        /// <param name="outer">The first sequence to join.</param>
        /// <param name="inner">The sequence to join to the first sequence.</param>
        /// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        /// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        /// <param name="resultSelector">
        /// A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.
        /// </param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements of type <typeparamref name="TResult"/> obtained by performing a grouped join on two
        /// sequences.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="outer"/> or <paramref name="inner"/> or <paramref name="outerKeySelector"/> or <paramref name="innerKeySelector"/> or
        /// <paramref name="resultSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(
            this DataServiceQuery<TOuter> outer,
            IEnumerable<TInner> inner,
            Expression<Func<TOuter, TKey>> outerKeySelector,
            Expression<Func<TInner, TKey>> innerKeySelector,
            Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
        {
            return new DataServiceQuery<TResult>(
                outer.AsQueryable().GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector).Expression,
                new DataServiceQueryProvider(outer.Context));
        }

        /// <summary>
        /// Produces the set intersection of two sequences by using the specified <see cref="IEqualityComparer{T}"/> to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="source1">A <see cref="DataServiceQuery{TElement}"/> whose distinct elements that also appear in <paramref name="source2"/> are returned.</param>
        /// <param name="source2">An <see cref="IEnumerable{T}"/> whose distinct elements that also appear in the first sequence are returned.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to compare values.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains the set intersection of the two sequences.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source1"/> or <paramref name="source2"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Intersect<TSource>(
            this DataServiceQuery<TSource> source1,
            IEnumerable<TSource> source2,
            IEqualityComparer<TSource> comparer)
        {
            return new DataServiceQuery<TSource>(source1.AsQueryable().Intersect(source2, comparer).Expression, new DataServiceQueryProvider(source1.Context));
        }

        /// <summary>
        /// Produces the set intersection of two sequences by using the default equality comparer to compare values.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="source1">A sequence whose distinct elements that also appear in <paramref name="source2"/> are returned.</param>
        /// <param name="source2">A sequence whose distinct elements that also appear in the first sequence are returned.</param>
        /// <returns>A sequence that contains the set intersection of the two sequences.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source1"/> or <paramref name="source2"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Intersect<TSource>(this DataServiceQuery<TSource> source1, IEnumerable<TSource> source2)
        {
            return new DataServiceQuery<TSource>(source1.AsQueryable().Intersect(source2).Expression, new DataServiceQueryProvider(source1.Context));
        }

        /// <summary>
        /// Correlates the elements of two sequences based on matching keys. A specified <see cref="IEqualityComparer{T}"/> is used to compare keys.
        /// </summary>
        /// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
        /// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
        /// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
        /// <typeparam name="TResult">The type of the result elements.</typeparam>
        /// <param name="outer">The first sequence to join.</param>
        /// <param name="inner">The sequence to join to the first sequence.</param>
        /// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        /// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        /// <param name="resultSelector">A function to create a result element from two matching elements.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to hash and compare keys.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that has elements of type <typeparamref name="TResult"/> obtained by performing an inner join on two sequences.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="outer"/> or <paramref name="inner"/> or <paramref name="outerKeySelector"/> or <paramref name="innerKeySelector"/> or
        /// <paramref name="resultSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> Join<TOuter, TInner, TKey, TResult>(
            this DataServiceQuery<TOuter> outer,
            IEnumerable<TInner> inner,
            Expression<Func<TOuter, TKey>> outerKeySelector,
            Expression<Func<TInner, TKey>> innerKeySelector,
            Expression<Func<TOuter, TInner, TResult>> resultSelector,
            IEqualityComparer<TKey> comparer)
        {
            return new DataServiceQuery<TResult>(
                outer.AsQueryable().Join(inner, outerKeySelector, innerKeySelector, resultSelector, comparer).Expression,
                new DataServiceQueryProvider(outer.Context));
        }

        /// <summary>
        /// Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.
        /// </summary>
        /// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
        /// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
        /// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
        /// <typeparam name="TResult">The type of the result elements.</typeparam>
        /// <param name="outer">The first sequence to join.</param>
        /// <param name="inner">The sequence to join to the first sequence.</param>
        /// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
        /// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
        /// <param name="resultSelector">A function to create a result element from two matching elements.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that has elements of type <typeparamref name="TResult"/> obtained by performing an inner join on two sequences.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="outer"/> or <paramref name="inner"/> or <paramref name="outerKeySelector"/> or <paramref name="innerKeySelector"/> or
        /// <paramref name="resultSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> Join<TOuter, TInner, TKey, TResult>(
            this DataServiceQuery<TOuter> outer,
            IEnumerable<TInner> inner,
            Expression<Func<TOuter, TKey>> outerKeySelector,
            Expression<Func<TInner, TKey>> innerKeySelector,
            Expression<Func<TOuter, TInner, TResult>> resultSelector)
        {
            return new DataServiceQuery<TResult>(
                outer.AsQueryable().Join(inner, outerKeySelector, innerKeySelector, resultSelector).Expression,
                new DataServiceQueryProvider(outer.Context));
        }

        /// <summary>
        /// Sorts the elements of a sequence in ascending order by using a specified comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A sequence of values to order.</param>
        /// <param name="keySelector">A function to extract a key from an element.</param>
        /// <param name="comparer">An <see cref="IComparer{T}"/> to compare keys.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> whose elements are sorted according to a key.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="comparer"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery OrderBy<TSource, TKey>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            IComparer<TKey> comparer)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsQueryable().OrderBy(keySelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Sorts the elements of a sequence in ascending order according to a key.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A sequence of values to order.</param>
        /// <param name="keySelector">A function to extract a key from an element.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> whose elements are sorted according to a key.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="keySelector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery OrderBy<TSource, TKey>(
            this DataServiceQuery<TSource> source, 
            Expression<Func<TSource, TKey>> keySelector)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsQueryable().OrderBy(keySelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Sorts the elements of a sequence in descending order according to a key.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A sequence of values to order.</param>
        /// <param name="keySelector">A function to extract a key from an element.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> whose elements are sorted in descending order according to a key.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="keySelector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery OrderByDescending<TSource, TKey>(
            this DataServiceQuery<TSource> source, 
            Expression<Func<TSource, TKey>> keySelector)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsQueryable().OrderByDescending(keySelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Sorts the elements of a sequence in descending order by using a specified comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A sequence of values to order.</param>
        /// <param name="keySelector">A function to extract a key from an element.</param>
        /// <param name="comparer">An <see cref="IComparer{T}"/> to compare keys.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> whose elements are sorted in descending order according to a key.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="comparer"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery OrderByDescending<TSource, TKey>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, TKey>> keySelector,
            IComparer<TKey> comparer)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsQueryable().OrderByDescending(keySelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Inverts the order of the elements in a sequence.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">A sequence of values to reverse.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> whose elements correspond to those of the input sequence in reverse order.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Reverse<TSource>(this DataServiceQuery<TSource> source)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().Reverse().Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Projects each element of a sequence into a new form by incorporating the element's index.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TResult">The type of the value returned by the function represented by <paramref name="selector"/>.</typeparam>
        /// <param name="source">A sequence of values to project.</param>
        /// <param name="selector">A projection function to apply to each element.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> whose elements are the result of invoking a projection function on each element of <paramref name="source"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="selector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TResult> Select<TSource, TResult>(this DataServiceQuery<TSource> source, Expression<Func<TSource, int, TResult>> selector)
        {
            return new DataServiceQuery<TResult>(source.AsQueryable().Select(selector).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Projects each element of a sequence into a new form.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TResult">The type of the value returned by the function represented by <paramref name="selector"/>.</typeparam>
        /// <param name="source">A sequence of values to project.</param>
        /// <param name="selector">A projection function to apply to each element.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> whose elements are the result of invoking a projection function on each element of <paramref name="source"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="selector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TResult> Select<TSource, TResult>(this DataServiceQuery<TSource> source, Expression<Func<TSource, TResult>> selector)
        {
            return new DataServiceQuery<TResult>(source.AsQueryable().Select(selector).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Projects each element of a sequence to an <see cref="IEnumerable{T}"/> and combines the resulting sequences into one sequence.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TResult">The type of the elements of the sequence returned by the function represented by <paramref name="selector"/>.</typeparam>
        /// <param name="source">A sequence of values to project.</param>
        /// <param name="selector">A projection function to apply to each element.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="selector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TResult> SelectMany<TSource, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, IEnumerable<TResult>>> selector)
        {
            return new DataServiceQuery<TResult>(source.AsQueryable().SelectMany(selector).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Projects each element of a sequence to an <see cref="IEnumerable{T}"/> and combines the resulting sequences into one sequence. The index of each source
        /// element is used in the projected form of that element.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TResult">The type of the elements of the sequence returned by the function represented by <paramref name="selector"/>.</typeparam>
        /// <param name="source">A sequence of values to project.</param>
        /// <param name="selector">
        /// A projection function to apply to each element; the second parameter of this function represents the index of the source element.
        /// </param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="selector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TResult> SelectMany<TSource, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, int, IEnumerable<TResult>>> selector)
        {
            return new DataServiceQuery<TResult>(source.AsQueryable().SelectMany(selector).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Projects each element of a sequence to an <see cref="IEnumerable{T}"/> that incorporates the index of the source element that produced it. A result selector
        /// function is invoked on each element of each intermediate sequence, and the resulting values are combined into a single, one-dimensional sequence and
        /// returned.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TCollection">
        /// The type of the intermediate elements collected by the function represented by <paramref name="collectionSelector"/>.
        /// </typeparam>
        /// <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
        /// <param name="source">A sequence of values to project.</param>
        /// <param name="collectionSelector">
        /// A projection function to apply to each element of the input sequence; the second parameter of this function represents the index of the source element.
        /// </param>
        /// <param name="resultSelector">A projection function to apply to each element of each intermediate sequence.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> whose elements are the result of invoking the one-to-many projection function
        /// <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequence elements and their corresponding
        /// <paramref name="source"/> element to a result element.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> SelectMany<TSource, TCollection, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, int, IEnumerable<TCollection>>> collectionSelector,
            Expression<Func<TSource, TCollection, TResult>> resultSelector)
        {
            return new DataServiceQuery<TResult>(
                source.AsQueryable().SelectMany(collectionSelector, resultSelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Projects each element of a sequence to an <see cref="IEnumerable{T}"/> and invokes a result selector function on each element therein. The resulting values
        /// from each intermediate sequence are combined into a single, one-dimensional sequence and returned.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TCollection">
        /// The type of the intermediate elements collected by the function represented by <paramref name="collectionSelector"/>.
        /// </typeparam>
        /// <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
        /// <param name="source">A sequence of values to project.</param>
        /// <param name="collectionSelector">A projection function to apply to each element of the input sequence.</param>
        /// <param name="resultSelector">A projection function to apply to each element of each intermediate sequence.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> whose elements are the result of invoking the one-to-many projection function
        /// <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequence elements and their corresponding
        /// <paramref name="source"/> element to a result element.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="collectionSelector"/> or <paramref name="resultSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> SelectMany<TSource, TCollection, TResult>(
            this DataServiceQuery<TSource> source,
            Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector,
            Expression<Func<TSource, TCollection, TResult>> resultSelector)
        {
            return new DataServiceQuery<TResult>(
                source.AsQueryable().SelectMany(collectionSelector, resultSelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Bypasses a specified number of elements in a sequence and then returns the remaining elements.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> to return elements from.</param>
        /// <param name="count">The number of elements to skip before returning the remaining elements.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains elements that occur after the specified index in the input sequence.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Skip<TSource>(this DataServiceQuery<TSource> source, int count)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().Skip(count).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> to return elements from.</param>
        /// <param name="predicate">A function to test each element for a condition.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements from <paramref name="source"/> starting at the first element in the linear series that does
        /// not pass the test specified by <paramref name="predicate"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> SkipWhile<TSource>(this DataServiceQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().SkipWhile(predicate).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of
        /// the predicate function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> to return elements from.</param>
        /// <param name="predicate">
        /// A function to test each element for a condition; the second parameter of this function represents the index of the source element.
        /// </param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements from <paramref name="source"/> starting at the first element in the linear series that does
        /// not pass the test specified by <paramref name="predicate"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> SkipWhile<TSource>(this DataServiceQuery<TSource> source, Expression<Func<TSource, int, bool>> predicate)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().SkipWhile(predicate).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Returns a specified number of contiguous elements from the start of a sequence.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">The sequence to return elements from.</param>
        /// <param name="count">The number of elements to return.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains the specified number of elements from the start of <paramref name="source"/>.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Take<TSource>(this DataServiceQuery<TSource> source, int count)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().Take(count).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Returns elements from a sequence as long as a specified condition is true.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">The sequence to return elements from.</param>
        /// <param name="predicate">A function to test each element for a condition.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements from the input sequence occurring before the element at which the test specified by
        /// <paramref name="predicate"/> no longer passes.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> TakeWhile<TSource>(this DataServiceQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().TakeWhile(predicate).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">The sequence to return elements from.</param>
        /// <param name="predicate">
        /// A function to test each element for a condition; the second parameter of the function represents the index of the element in the source sequence.
        /// </param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements from the input sequence occurring before the element at which the test specified by
        /// <paramref name="predicate"/> no longer passes.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> TakeWhile<TSource>(this DataServiceQuery<TSource> source, Expression<Func<TSource, int, bool>> predicate)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().TakeWhile(predicate).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Performs a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented by <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> that contains elements to sort.</param>
        /// <param name="keySelector">A function to extract a key from each element.</param>
        /// <param name="comparer">An <see cref="IComparer{T}"/> to compare keys.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> whose elements are sorted according to a key.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="comparer"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery ThenBy<TSource, TKey>(
            this DataServiceQuery<TSource>.DataServiceOrderedQuery source,
            Expression<Func<TSource, TKey>> keySelector,
            IComparer<TKey> comparer)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsOrderedQueryable().ThenBy(keySelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented by <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> that contains elements to sort.</param>
        /// <param name="keySelector">A function to extract a key from each element.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> whose elements are sorted according to a key.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="keySelector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery ThenBy<TSource, TKey>(
            this DataServiceQuery<TSource>.DataServiceOrderedQuery source,
            Expression<Func<TSource, TKey>> keySelector)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsOrderedQueryable().ThenBy(keySelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key returned by the function represented by <paramref name="keySelector"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> that contains elements to sort.</param>
        /// <param name="keySelector">A function to extract a key from each element.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/> whose elements are sorted in descending order according to a key.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="keySelector"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery ThenByDescending<TSource, TKey>(
            this DataServiceQuery<TSource>.DataServiceOrderedQuery source,
            Expression<Func<TSource, TKey>> keySelector)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsOrderedQueryable().ThenByDescending(keySelector).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Performs a subsequent ordering of the elements in a sequence in descending order by using a specified comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <typeparam name="TKey">The type of the key that is returned by the <paramref name="keySelector"/> function.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}.DataServiceOrderedQuery"/><T> that contains elements to sort.</param>
        /// <param name="keySelector">A function to extract a key from each element.</param>
        /// <param name="comparer">An <see cref="IComparer{T}"/> to compare keys.</param>
        /// <returns>A collection whose elements are sorted in descending order according to a key.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source"/> or <paramref name="keySelector"/> or <paramref name="comparer"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TSource>.DataServiceOrderedQuery ThenByDescending<TSource, TKey>(
            this DataServiceQuery<TSource>.DataServiceOrderedQuery source,
            Expression<Func<TSource, TKey>> keySelector,
            IComparer<TKey> comparer)
        {
            return new DataServiceQuery<TSource>.DataServiceOrderedQuery(
                source.AsOrderedQueryable().ThenByDescending(keySelector, comparer).Expression,
                new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Produces the set union of two sequences by using a specified <see cref="IEqualityComparer{T}"/>.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="source1">A sequence whose distinct elements form the first set for the union operation.</param>
        /// <param name="source2">A sequence whose distinct elements form the second set for the union operation.</param>
        /// <param name="comparer">An <see cref="IEqualityComparer{T}"/> to compare values.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains the elements from both input sequences, excluding duplicates.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source1"/> or <paramref name="source2"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Union<TSource>(this DataServiceQuery<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
        {
            return new DataServiceQuery<TSource>(source1.AsQueryable().Union(source2, comparer).Expression, new DataServiceQueryProvider(source1.Context));
        }

        /// <summary>
        /// Produces the set union of two sequences by using the default equality comparer.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
        /// <param name="source1">A sequence whose distinct elements form the first set for the union operation.</param>
        /// <param name="source2">A sequence whose distinct elements form the second set for the union operation.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains the elements from both input sequences, excluding duplicates.</returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source1"/> or <paramref name="source2"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Union<TSource>(this DataServiceQuery<TSource> source1, IEnumerable<TSource> source2)
        {
            return new DataServiceQuery<TSource>(source1.AsQueryable().Union(source2).Expression, new DataServiceQueryProvider(source1.Context));
        }

        /// <summary>
        /// Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> to filter.</param>
        /// <param name="predicate">
        /// A function to test each element for a condition; the second parameter of the function represents the index of the element in the source sequence.
        /// </param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements from the input sequence that satisfy the condition specified by
        /// <paramref name="predicate"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Where<TSource>(this DataServiceQuery<TSource> source, Expression<Func<TSource, int, bool>> predicate)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().Where(predicate).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Filters a sequence of values based on a predicate.
        /// </summary>
        /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
        /// <param name="source">A <see cref="DataServiceQuery{TElement}"/> to filter.</param>
        /// <param name="predicate">A function to test each element for a condition.</param>
        /// <returns>
        /// A <see cref="DataServiceQuery{TElement}"/> that contains elements from the input sequence that satisfy the condition specified by
        /// <paramref name="predicate"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="source"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        public static DataServiceQuery<TSource> Where<TSource>(this DataServiceQuery<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            return new DataServiceQuery<TSource>(source.AsQueryable().Where(predicate).Expression, new DataServiceQueryProvider(source.Context));
        }

        /// <summary>
        /// Merges two sequences by using the specified predicate function.
        /// </summary>
        /// <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
        /// <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
        /// <typeparam name="TResult">The type of the elements of the result sequence.</typeparam>
        /// <param name="source1">The first sequence to merge.</param>
        /// <param name="source2">The second sequence to merge.</param>
        /// <param name="resultSelector">A function that specifies how to merge the elements from the two sequences.</param>
        /// <returns>A <see cref="DataServiceQuery{TElement}"/> that contains merged elements of two input sequences.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="source1"/> or <paramref name="source2"/> or <paramref name="resultSelector"/> is <see langword="null"/>
        /// </exception>
        public static DataServiceQuery<TResult> Zip<TFirst, TSecond, TResult>(
            this DataServiceQuery<TFirst> source1,
            IEnumerable<TSecond> source2,
            Expression<Func<TFirst, TSecond, TResult>> resultSelector)
        {
            return new DataServiceQuery<TResult>(source1.AsQueryable().Zip(source2, resultSelector).Expression, new DataServiceQueryProvider(source1.Context));
        }
    }
}
