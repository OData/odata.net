//---------------------------------------------------------------------
// <copyright file="SearchLexer.cs" company="Microsoft">
//      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------

namespace Microsoft.OData.UriParser
{
    #region Namespaces
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Text.RegularExpressions;
        #endregion Namespaces

    /// <summary>
    /// Lexer used for search query, note this is a little different ExpressionLexer, that it use double quote as string indicator.
    /// TODO: Extend the expression lexer.
    /// The result generated by this lexer:
    /// AND, OR, NOT        Identifier
    /// (                   OpenParen
    /// )                   CloseParen
    /// (others)            StringLiteral
    /// </summary>
    [DebuggerDisplay("SearchLexer ({text} @ {textPos} [{token}])")]
    internal sealed class SearchLexer : ExpressionLexer
    {
        /// <summary>
        /// Pattern for searchWord
        /// From ABNF rule:
        /// searchWord   = 1*ALPHA ; Actually: any character from the Unicode categories L or Nl,
        ///               ; but not the words AND, OR, and NOT
        ///
        /// \p{L} means any kind of letter from any language, include [Lo] such as CJK single character.
        /// </summary>
        internal static readonly Regex InvalidWordPattern = new Regex(@"([^\p{L}\p{Nl}])");

        /// <summary>
        /// Escape character used in search query
        /// </summary>
        private const char EscapeChar = '\\';

        /// <summary>
        /// Characters that could be escaped
        /// </summary>
        private const string EscapeSequenceSet = "\\\"";

        /// <summary>
        /// Indicate whether current char is escaped.
        /// </summary>
        private bool isEscape;

        /// <summary>Initializes a new <see cref="SearchLexer"/>.</summary>
        /// <param name="expression">Expression to parse.</param>
        internal SearchLexer(string expression)
            : base(expression, true /*moveToFirstToken*/, false /*useSemicolonDelimiter*/)
        {
        }

        /// <summary>Reads the next token, skipping whitespace as necessary.</summary>
        /// <param name="error">Error that occurred while trying to process the next token.</param>
        /// <returns>The next token, which may be 'bad' if an error occurs.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "This parser method is all about the switch statement and would be harder to maintain if it were broken up.")]
        protected override ExpressionToken NextTokenImplementation(out Exception error)
        {
            error = null;

            this.ParseWhitespace();

            ExpressionTokenKind t;
            int tokenPos = this.textPos;
            switch (this.ch)
            {
                case '(':
                    this.NextChar();
                    t = ExpressionTokenKind.OpenParen;
                    break;
                case ')':
                    this.NextChar();
                    t = ExpressionTokenKind.CloseParen;
                    break;
                case '"':
                    char quote = this.ch.Value;

                    this.AdvanceToNextOccurenceOfWithEscape(quote);

                    if (this.textPos == this.TextLen)
                    {
                        throw ParseError(Strings.ExpressionLexer_UnterminatedStringLiteral(this.textPos, this.Text));
                    }

                    this.NextChar();

                    t = ExpressionTokenKind.StringLiteral;
                    break;
                default:
                    if (this.textPos == this.TextLen)
                    {
                        t = ExpressionTokenKind.End;
                    }
                    else
                    {
                        t = ExpressionTokenKind.Identifier;
                        do
                        {
                            this.NextChar();
                        } while (this.ch.HasValue && IsValidSearchTermChar(this.ch.Value));
                    }

                    break;
            }

            this.token.Kind = t;
            this.token.Text = this.Text.AsMemory(tokenPos, this.textPos - tokenPos);
            this.token.Position = tokenPos;

            if (this.token.Kind == ExpressionTokenKind.StringLiteral)
            {
                string slicedText = this.token.Text.Slice(1, this.token.Length - 2).ToString(); // remove the leading and ending quotes
                slicedText = slicedText.Replace("\\\\", "\\", StringComparison.Ordinal).Replace("\\\"", "\"", StringComparison.Ordinal);
                this.token.Text = slicedText.AsMemory();

                if (this.token.Text.IsEmpty)
                {
                    throw ParseError(Strings.ExpressionToken_IdentifierExpected(this.token.Position));
                }
            }

            if ((this.token.Kind == ExpressionTokenKind.Identifier) && !IsKeyWord(this.token.Span))
            {
                if (InvalidWordPattern.IsMatch(this.token.Span))
                {
                    Match match = InvalidWordPattern.Match(this.token.Text.ToString());
                    int index = match.Groups[0].Index;
                    throw ParseError(Strings.ExpressionLexer_InvalidCharacter(this.token.Span[index], this.token.Position + index, this.Text));
                }

                this.token.Kind = ExpressionTokenKind.StringLiteral;
            }

            return this.token;
        }

        /// <summary>
        /// Checks the text is the keywords can be used in search query.
        /// </summary>
        /// <param name="text">the token text.</param>
        /// <returns>Whether the text is key word in search query.</returns>
        private static bool IsKeyWord(ReadOnlySpan<char> text)
        {
            return text.Equals(ExpressionConstants.SearchKeywordAnd, StringComparison.Ordinal) || // "AND"
                text.Equals(ExpressionConstants.SearchKeywordOr, StringComparison.Ordinal) || // "OR"
                text.Equals(ExpressionConstants.SearchKeywordNot, StringComparison.Ordinal); // "NOT"
        }

        /// <summary>
        /// Evaluate whether the given char is valid for a SearchTerm
        /// </summary>
        /// <param name="val">The char to be evaluated on.</param>
        /// <returns>Whether the given char is valid for a SearchTerm</returns>
        private static bool IsValidSearchTermChar(char val)
        {
            return !Char.IsWhiteSpace(val) && val != ')';
        }

        /// <summary>
        /// Move to next char, with escape char support.
        /// </summary>
        private void NextCharWithEscape()
        {
            this.isEscape = false;
            this.NextChar();
            if (this.ch == EscapeChar)
            {
                this.isEscape = true;
                this.NextChar();

                if (!this.ch.HasValue || EscapeSequenceSet.IndexOf(this.ch.Value, StringComparison.Ordinal) < 0)
                {
                    throw ParseError(Strings.ExpressionLexer_InvalidEscapeSequence(this.ch, this.textPos, this.Text));
                }
            }
        }

        /// <summary>
        /// Advance to certain char, with escape char support.
        /// </summary>
        /// <param name="endingValue">the ending delimiter.</param>
        private void AdvanceToNextOccurenceOfWithEscape(char endingValue)
        {
            this.NextCharWithEscape();
            while (this.ch.HasValue && !(this.ch == endingValue && !this.isEscape))
            {
                this.NextCharWithEscape();
            }
        }
    }
}
