<#@ assembly name="System.Core"
#><#@ assembly name="System.Xml"
#><#@ assembly name="System.Xml.Linq"
#><#@ import namespace="System"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.IO"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Text"
#><#@ import namespace="System.Security"
#><#@ import namespace="System.Xml.Linq"
#><#@ import namespace="Microsoft.VisualStudio.TextTemplating"
#><#@ assembly name="EnvDTE"
#><#+
/// <summary>
/// Creates an instance of the FilesManager. The object used to generate and manage
/// multiple source files.
/// </summary>
/// <param name="context">The code generation context.</param>
public class FilesManager {
    
    private class Block {
        public string Name;
        public int Start, Length;
        public bool IsContainer;
    }

    private Block _currentBlock;
    private List<Block> _files = new List<Block>();
    private Block _footer = new Block();
    private Block _header = new Block();
    private ITextTemplatingEngineHost _host;   
    protected List<String> generatedFileNames = new List<String>();

    public StringBuilder template
        {
            get; 
            set;
        }

    [SecurityCritical]
    public static FilesManager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new FilesManager(host, template);
    }

    public void StartNewFile(string name, bool isContainer) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name, IsContainer =  isContainer};
    }

    public void StartFooter() {
        CurrentBlock = _footer;
    }

    public void StartHeader() {
        CurrentBlock = _header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != _header && CurrentBlock != _footer)
            _files.Add(CurrentBlock);
        _currentBlock = null;
    }

    [SecurityCritical]
    public virtual void GenerateFiles(bool split) {
        if (split) {
            EndBlock();
            string headerText = template.ToString(_header.Start, _header.Length);
            string footerText = template.ToString(_footer.Start, _footer.Length);
            string outputPath ="";

            if(_host != null){
                Path.GetDirectoryName(_host.TemplateFile);
            }
            
            _files.Reverse();
            foreach(Block block in _files) {
                if(block.IsContainer) continue;
                string fileName = Path.Combine(outputPath, block.Name);
                string content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(string fileName, string content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual string GetCustomToolNamespace(string fileName) {
        return null;
    }

    public virtual string DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(string fileName, string newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }
    
    [SecurityCritical]
    private FilesManager(ITextTemplatingEngineHost host, StringBuilder template) {
        _host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return _currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            _currentBlock = value;
        }
    }

    private class VSManager : FilesManager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override string DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override string GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }
        
        [SecurityCritical]
        public override void GenerateFiles(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.GenerateFiles(split);
            projectSyncAction.Invoke(generatedFileNames);
        }

        protected override void CreateFile(string fileName, string content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = host as IServiceProvider;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = hostServiceProvider.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (string fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            HashSet<String> keepFileNameSet = new HashSet<String>(keepFileNames);
            Dictionary<String, EnvDTE.ProjectItem> projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            string originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            foreach(KeyValuePair<string, EnvDTE.ProjectItem> pair in projectFiles)
                if (!keepFileNameSet.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            foreach(string fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(string fileName) {
            var sourceControl = dte.SourceControl;
            if (sourceControl != null && sourceControl.IsItemUnderSCC(fileName) && !sourceControl.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
} #>
