consider the perspectives:
1. customer
2. workload
3. ags
4. graphclient
5. odataclient
6. minimal api
7. what was that team who was going to use filter expressions?





TODO
{
clean up the readers and writers to have more consistency
do ref structs in readers and writers //// TODO have the interfaces that use fewer type parameters too
TODO the delegate accepters could be ref structs
}
TODO fix disposer async and lock //// TODO do you need to lock? writers aren't actually thread-safe
TODO re-organize the samples and then add samples pretending to be each framework consumer
	TODO implement a data store `iconvention`
	TODO a `iconvention` implementation that doesn't have a client factory because it uses the way to specify headers per request

TODO
{
TODO to help answer the below, at some layer, you need to be using the "standard's language" instead of the "http language"; so, for example, at some point, instead of `get` you need to call the method `retrieve`; instead of `patch`, `update`; you need a method for `upsert` (probably); you need a method for `requestchangetracking`; a method for `insert`; a method for `deepinsert`; `deepupdate` too? etc
TODO at what point should there be the "incoming stream" + "outgoing stream" representation?
TODO what is some generic value-add at each level that you can implement to demonstrate the utility of modeling in that level?
}

TODO demonstrate what happens when reader tokens have a new DU member
TODO somehow communicate that only the "deepest" reader or writer should be disposed; disposing an earlier reader or writer will affect later readers and writers
TODO use pipe reader and pipe writer instead of your custom "readstream" and "writestream"?
TODO you've lost covariance in the writers by making them async; you also already lose covariance with the abstract tokens
TODO add a "count" to the `multivaluedprotocol` implementation
TODO add "nullproperties" to `singlevalue` and then update the `multivalueprotocol` implementation
TODO model "nextlink" for a nestedproperty and then implement it in `multivalueprotocol`
TODO flesh out a complexrequestproperty and then update `multivalueprotocol` implementation
TODO if you were to really take the reader/writer thing to the exteme, you would have readers always return a token
TODO what would it look like for the readers and writers (and their tokens probably) to be `ref struct`s?
TODO add back the entity<tentity, tkey> thing; i like it because it ensures the tkey is defined somewhere cohesive with the rest of the properties of the entity; you need to consider how multi-part keys work though; and what about service-provided vs client-provided keys?
TODO address todos within the code
TODO probably _3_context should be about `idatastore`
TODO what about error conditions?
TODO at what point does an instance of the edm model come into play? and what can you do to make it so that the edm model gets added through composability and it's not always required (meaning, there's value you can get even if you don't have the edm model)
TODO can you have disposer be a ref struct

TODO binary JSON or use something like ProtoBuff

TODO at the protocol level could be an AGS implementation that puts the "users" from several workloads into a single collection



TODO is there something at the CLR level that can expose the whole "metadata"? something like `graphroot` that can have a `.users` that is of the correct `user` type, and so on?