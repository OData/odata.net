consider the perspectives:
1. customer
2. workload
3. ags
4. graphclient
5. odataclient




TODO implement the request writers
TODO implement something that translates the odatamaxversion header of a request
TODO go to the convention level
TODO add back the entity<tentity, tkey> thing; i like it because it ensures the tkey is defined somewhere cohesive with the rest of the properties of the entity; you need to consider how multi-part keys work though; and what about service-provided vs client-provided keys?
TODO to help answer the below, at some layer, you need to be using the "standard's language" instead of the "http language"; so, for example, at some point, instead of `get` you need to call the method `retrieve`; instead of `patch`, `update`; you need a method for `upsert` (probably); you need a method for `requestchangetracking`; a method for `insert`; a method for `deepinsert`; `deepupdate` too? etc
TODO at what point should there be the "incoming stream" + "outgoing stream" representation?
TODO address todos within the code
TODO what is some generic value-add at each level that you can implement to demonstrate the utility of modeling in that level?
TODO probably _3_context should be about `idatastore`
TODO what about error conditions?
TODO at what point does an instance of the edm model come into play? and what can you do to make it so that the edm model gets added through composability and it's not always required (meaning, there's value you can get even if you don't have the edm model)


TODO at the protocol level could be an AGS implementation that puts the "users" from several workloads into a single collection



TODO is there something at the CLR level that can expose the whole "metadata"? something like `graphroot` that can have a `.users` that is of the correct `user` type, and so on?