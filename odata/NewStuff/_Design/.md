consider the perspectives:
1. customer
2. workload
3. ags
4. graphclient
5. odataclient





TODO do whatever is needed for async; look at the `httpconvention` as the root to start bubbling things up
TODO do whatever is needed for disposable; look at the `httpconvention` as the root to start bubbling things up
TODO re-organize the samples and then add samples pretending to be each framework consumer
	TODO implement a data store `iconvention`
	TODO a `iconvention` implementation that doesn't have a client factory because it uses the way to specify headers per request
TODO to help answer the below, at some layer, you need to be using the "standard's language" instead of the "http language"; so, for example, at some point, instead of `get` you need to call the method `retrieve`; instead of `patch`, `update`; you need a method for `upsert` (probably); you need a method for `requestchangetracking`; a method for `insert`; a method for `deepinsert`; `deepupdate` too? etc
TODO at what point should there be the "incoming stream" + "outgoing stream" representation?
TODO what is some generic value-add at each level that you can implement to demonstrate the utility of modeling in that level?

TODO add a "count" to the `multivaluedprotocol` implementation
TODO add "nullproperties" to `singlevalue` and then update the `multivalueprotocol` implementation
TODO model "nextlink" for a nestedproperty and then implement it in `multivalueprotocol`
TODO flesh out a complexrequestproperty and then update `multivalueprotocol` implementation
TODO if you were to really take the reader/writer thing to the exteme, you would have readers always return a token
TODO what would it look like for the readers and writers (and their tokens probably) to be `ref struct`s?
TODO add back the entity<tentity, tkey> thing; i like it because it ensures the tkey is defined somewhere cohesive with the rest of the properties of the entity; you need to consider how multi-part keys work though; and what about service-provided vs client-provided keys?
TODO address todos within the code
TODO probably _3_context should be about `idatastore`
TODO what about error conditions?
TODO at what point does an instance of the edm model come into play? and what can you do to make it so that the edm model gets added through composability and it's not always required (meaning, there's value you can get even if you don't have the edm model)


TODO at the protocol level could be an AGS implementation that puts the "users" from several workloads into a single collection



TODO is there something at the CLR level that can expose the whole "metadata"? something like `graphroot` that can have a `.users` that is of the correct `user` type, and so on?