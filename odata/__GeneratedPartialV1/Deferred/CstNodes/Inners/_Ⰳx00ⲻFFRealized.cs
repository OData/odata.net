namespace __GeneratedPartialV1.Deferred.CstNodes.Inners
{
    using System;
    using CombinatorParsingV3;
    
    public abstract class _Ⰳx00ⲻFFRealized : IFromRealizedable<_Ⰳx00ⲻFFDeferred>
    {
        private _Ⰳx00ⲻFFRealized()
        {
        }
        
        public abstract _Ⰳx00ⲻFFDeferred Convert();
        protected abstract TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context);
        
        public abstract class Visitor<TResult, TContext>
        {
            public TResult Visit(_Ⰳx00ⲻFFRealized node, TContext context)
            {
                return node.Dispatch(this, context);
            }
            
            protected internal abstract TResult Accept(_00 node, TContext context);
            protected internal abstract TResult Accept(_01 node, TContext context);
            protected internal abstract TResult Accept(_02 node, TContext context);
            protected internal abstract TResult Accept(_03 node, TContext context);
            protected internal abstract TResult Accept(_04 node, TContext context);
            protected internal abstract TResult Accept(_05 node, TContext context);
            protected internal abstract TResult Accept(_06 node, TContext context);
            protected internal abstract TResult Accept(_07 node, TContext context);
            protected internal abstract TResult Accept(_08 node, TContext context);
            protected internal abstract TResult Accept(_09 node, TContext context);
            protected internal abstract TResult Accept(_0A node, TContext context);
            protected internal abstract TResult Accept(_0B node, TContext context);
            protected internal abstract TResult Accept(_0C node, TContext context);
            protected internal abstract TResult Accept(_0D node, TContext context);
            protected internal abstract TResult Accept(_0E node, TContext context);
            protected internal abstract TResult Accept(_0F node, TContext context);
            protected internal abstract TResult Accept(_10 node, TContext context);
            protected internal abstract TResult Accept(_11 node, TContext context);
            protected internal abstract TResult Accept(_12 node, TContext context);
            protected internal abstract TResult Accept(_13 node, TContext context);
            protected internal abstract TResult Accept(_14 node, TContext context);
            protected internal abstract TResult Accept(_15 node, TContext context);
            protected internal abstract TResult Accept(_16 node, TContext context);
            protected internal abstract TResult Accept(_17 node, TContext context);
            protected internal abstract TResult Accept(_18 node, TContext context);
            protected internal abstract TResult Accept(_19 node, TContext context);
            protected internal abstract TResult Accept(_1A node, TContext context);
            protected internal abstract TResult Accept(_1B node, TContext context);
            protected internal abstract TResult Accept(_1C node, TContext context);
            protected internal abstract TResult Accept(_1D node, TContext context);
            protected internal abstract TResult Accept(_1E node, TContext context);
            protected internal abstract TResult Accept(_1F node, TContext context);
            protected internal abstract TResult Accept(_20 node, TContext context);
            protected internal abstract TResult Accept(_21 node, TContext context);
            protected internal abstract TResult Accept(_22 node, TContext context);
            protected internal abstract TResult Accept(_23 node, TContext context);
            protected internal abstract TResult Accept(_24 node, TContext context);
            protected internal abstract TResult Accept(_25 node, TContext context);
            protected internal abstract TResult Accept(_26 node, TContext context);
            protected internal abstract TResult Accept(_27 node, TContext context);
            protected internal abstract TResult Accept(_28 node, TContext context);
            protected internal abstract TResult Accept(_29 node, TContext context);
            protected internal abstract TResult Accept(_2A node, TContext context);
            protected internal abstract TResult Accept(_2B node, TContext context);
            protected internal abstract TResult Accept(_2C node, TContext context);
            protected internal abstract TResult Accept(_2D node, TContext context);
            protected internal abstract TResult Accept(_2E node, TContext context);
            protected internal abstract TResult Accept(_2F node, TContext context);
            protected internal abstract TResult Accept(_30 node, TContext context);
            protected internal abstract TResult Accept(_31 node, TContext context);
            protected internal abstract TResult Accept(_32 node, TContext context);
            protected internal abstract TResult Accept(_33 node, TContext context);
            protected internal abstract TResult Accept(_34 node, TContext context);
            protected internal abstract TResult Accept(_35 node, TContext context);
            protected internal abstract TResult Accept(_36 node, TContext context);
            protected internal abstract TResult Accept(_37 node, TContext context);
            protected internal abstract TResult Accept(_38 node, TContext context);
            protected internal abstract TResult Accept(_39 node, TContext context);
            protected internal abstract TResult Accept(_3A node, TContext context);
            protected internal abstract TResult Accept(_3B node, TContext context);
            protected internal abstract TResult Accept(_3C node, TContext context);
            protected internal abstract TResult Accept(_3D node, TContext context);
            protected internal abstract TResult Accept(_3E node, TContext context);
            protected internal abstract TResult Accept(_3F node, TContext context);
            protected internal abstract TResult Accept(_40 node, TContext context);
            protected internal abstract TResult Accept(_41 node, TContext context);
            protected internal abstract TResult Accept(_42 node, TContext context);
            protected internal abstract TResult Accept(_43 node, TContext context);
            protected internal abstract TResult Accept(_44 node, TContext context);
            protected internal abstract TResult Accept(_45 node, TContext context);
            protected internal abstract TResult Accept(_46 node, TContext context);
            protected internal abstract TResult Accept(_47 node, TContext context);
            protected internal abstract TResult Accept(_48 node, TContext context);
            protected internal abstract TResult Accept(_49 node, TContext context);
            protected internal abstract TResult Accept(_4A node, TContext context);
            protected internal abstract TResult Accept(_4B node, TContext context);
            protected internal abstract TResult Accept(_4C node, TContext context);
            protected internal abstract TResult Accept(_4D node, TContext context);
            protected internal abstract TResult Accept(_4E node, TContext context);
            protected internal abstract TResult Accept(_4F node, TContext context);
            protected internal abstract TResult Accept(_50 node, TContext context);
            protected internal abstract TResult Accept(_51 node, TContext context);
            protected internal abstract TResult Accept(_52 node, TContext context);
            protected internal abstract TResult Accept(_53 node, TContext context);
            protected internal abstract TResult Accept(_54 node, TContext context);
            protected internal abstract TResult Accept(_55 node, TContext context);
            protected internal abstract TResult Accept(_56 node, TContext context);
            protected internal abstract TResult Accept(_57 node, TContext context);
            protected internal abstract TResult Accept(_58 node, TContext context);
            protected internal abstract TResult Accept(_59 node, TContext context);
            protected internal abstract TResult Accept(_5A node, TContext context);
            protected internal abstract TResult Accept(_5B node, TContext context);
            protected internal abstract TResult Accept(_5C node, TContext context);
            protected internal abstract TResult Accept(_5D node, TContext context);
            protected internal abstract TResult Accept(_5E node, TContext context);
            protected internal abstract TResult Accept(_5F node, TContext context);
            protected internal abstract TResult Accept(_60 node, TContext context);
            protected internal abstract TResult Accept(_61 node, TContext context);
            protected internal abstract TResult Accept(_62 node, TContext context);
            protected internal abstract TResult Accept(_63 node, TContext context);
            protected internal abstract TResult Accept(_64 node, TContext context);
            protected internal abstract TResult Accept(_65 node, TContext context);
            protected internal abstract TResult Accept(_66 node, TContext context);
            protected internal abstract TResult Accept(_67 node, TContext context);
            protected internal abstract TResult Accept(_68 node, TContext context);
            protected internal abstract TResult Accept(_69 node, TContext context);
            protected internal abstract TResult Accept(_6A node, TContext context);
            protected internal abstract TResult Accept(_6B node, TContext context);
            protected internal abstract TResult Accept(_6C node, TContext context);
            protected internal abstract TResult Accept(_6D node, TContext context);
            protected internal abstract TResult Accept(_6E node, TContext context);
            protected internal abstract TResult Accept(_6F node, TContext context);
            protected internal abstract TResult Accept(_70 node, TContext context);
            protected internal abstract TResult Accept(_71 node, TContext context);
            protected internal abstract TResult Accept(_72 node, TContext context);
            protected internal abstract TResult Accept(_73 node, TContext context);
            protected internal abstract TResult Accept(_74 node, TContext context);
            protected internal abstract TResult Accept(_75 node, TContext context);
            protected internal abstract TResult Accept(_76 node, TContext context);
            protected internal abstract TResult Accept(_77 node, TContext context);
            protected internal abstract TResult Accept(_78 node, TContext context);
            protected internal abstract TResult Accept(_79 node, TContext context);
            protected internal abstract TResult Accept(_7A node, TContext context);
            protected internal abstract TResult Accept(_7B node, TContext context);
            protected internal abstract TResult Accept(_7C node, TContext context);
            protected internal abstract TResult Accept(_7D node, TContext context);
            protected internal abstract TResult Accept(_7E node, TContext context);
            protected internal abstract TResult Accept(_7F node, TContext context);
            protected internal abstract TResult Accept(_80 node, TContext context);
            protected internal abstract TResult Accept(_81 node, TContext context);
            protected internal abstract TResult Accept(_82 node, TContext context);
            protected internal abstract TResult Accept(_83 node, TContext context);
            protected internal abstract TResult Accept(_84 node, TContext context);
            protected internal abstract TResult Accept(_85 node, TContext context);
            protected internal abstract TResult Accept(_86 node, TContext context);
            protected internal abstract TResult Accept(_87 node, TContext context);
            protected internal abstract TResult Accept(_88 node, TContext context);
            protected internal abstract TResult Accept(_89 node, TContext context);
            protected internal abstract TResult Accept(_8A node, TContext context);
            protected internal abstract TResult Accept(_8B node, TContext context);
            protected internal abstract TResult Accept(_8C node, TContext context);
            protected internal abstract TResult Accept(_8D node, TContext context);
            protected internal abstract TResult Accept(_8E node, TContext context);
            protected internal abstract TResult Accept(_8F node, TContext context);
            protected internal abstract TResult Accept(_90 node, TContext context);
            protected internal abstract TResult Accept(_91 node, TContext context);
            protected internal abstract TResult Accept(_92 node, TContext context);
            protected internal abstract TResult Accept(_93 node, TContext context);
            protected internal abstract TResult Accept(_94 node, TContext context);
            protected internal abstract TResult Accept(_95 node, TContext context);
            protected internal abstract TResult Accept(_96 node, TContext context);
            protected internal abstract TResult Accept(_97 node, TContext context);
            protected internal abstract TResult Accept(_98 node, TContext context);
            protected internal abstract TResult Accept(_99 node, TContext context);
            protected internal abstract TResult Accept(_9A node, TContext context);
            protected internal abstract TResult Accept(_9B node, TContext context);
            protected internal abstract TResult Accept(_9C node, TContext context);
            protected internal abstract TResult Accept(_9D node, TContext context);
            protected internal abstract TResult Accept(_9E node, TContext context);
            protected internal abstract TResult Accept(_9F node, TContext context);
            protected internal abstract TResult Accept(_A0 node, TContext context);
            protected internal abstract TResult Accept(_A1 node, TContext context);
            protected internal abstract TResult Accept(_A2 node, TContext context);
            protected internal abstract TResult Accept(_A3 node, TContext context);
            protected internal abstract TResult Accept(_A4 node, TContext context);
            protected internal abstract TResult Accept(_A5 node, TContext context);
            protected internal abstract TResult Accept(_A6 node, TContext context);
            protected internal abstract TResult Accept(_A7 node, TContext context);
            protected internal abstract TResult Accept(_A8 node, TContext context);
            protected internal abstract TResult Accept(_A9 node, TContext context);
            protected internal abstract TResult Accept(_AA node, TContext context);
            protected internal abstract TResult Accept(_AB node, TContext context);
            protected internal abstract TResult Accept(_AC node, TContext context);
            protected internal abstract TResult Accept(_AD node, TContext context);
            protected internal abstract TResult Accept(_AE node, TContext context);
            protected internal abstract TResult Accept(_AF node, TContext context);
            protected internal abstract TResult Accept(_B0 node, TContext context);
            protected internal abstract TResult Accept(_B1 node, TContext context);
            protected internal abstract TResult Accept(_B2 node, TContext context);
            protected internal abstract TResult Accept(_B3 node, TContext context);
            protected internal abstract TResult Accept(_B4 node, TContext context);
            protected internal abstract TResult Accept(_B5 node, TContext context);
            protected internal abstract TResult Accept(_B6 node, TContext context);
            protected internal abstract TResult Accept(_B7 node, TContext context);
            protected internal abstract TResult Accept(_B8 node, TContext context);
            protected internal abstract TResult Accept(_B9 node, TContext context);
            protected internal abstract TResult Accept(_BA node, TContext context);
            protected internal abstract TResult Accept(_BB node, TContext context);
            protected internal abstract TResult Accept(_BC node, TContext context);
            protected internal abstract TResult Accept(_BD node, TContext context);
            protected internal abstract TResult Accept(_BE node, TContext context);
            protected internal abstract TResult Accept(_BF node, TContext context);
            protected internal abstract TResult Accept(_C0 node, TContext context);
            protected internal abstract TResult Accept(_C1 node, TContext context);
            protected internal abstract TResult Accept(_C2 node, TContext context);
            protected internal abstract TResult Accept(_C3 node, TContext context);
            protected internal abstract TResult Accept(_C4 node, TContext context);
            protected internal abstract TResult Accept(_C5 node, TContext context);
            protected internal abstract TResult Accept(_C6 node, TContext context);
            protected internal abstract TResult Accept(_C7 node, TContext context);
            protected internal abstract TResult Accept(_C8 node, TContext context);
            protected internal abstract TResult Accept(_C9 node, TContext context);
            protected internal abstract TResult Accept(_CA node, TContext context);
            protected internal abstract TResult Accept(_CB node, TContext context);
            protected internal abstract TResult Accept(_CC node, TContext context);
            protected internal abstract TResult Accept(_CD node, TContext context);
            protected internal abstract TResult Accept(_CE node, TContext context);
            protected internal abstract TResult Accept(_CF node, TContext context);
            protected internal abstract TResult Accept(_D0 node, TContext context);
            protected internal abstract TResult Accept(_D1 node, TContext context);
            protected internal abstract TResult Accept(_D2 node, TContext context);
            protected internal abstract TResult Accept(_D3 node, TContext context);
            protected internal abstract TResult Accept(_D4 node, TContext context);
            protected internal abstract TResult Accept(_D5 node, TContext context);
            protected internal abstract TResult Accept(_D6 node, TContext context);
            protected internal abstract TResult Accept(_D7 node, TContext context);
            protected internal abstract TResult Accept(_D8 node, TContext context);
            protected internal abstract TResult Accept(_D9 node, TContext context);
            protected internal abstract TResult Accept(_DA node, TContext context);
            protected internal abstract TResult Accept(_DB node, TContext context);
            protected internal abstract TResult Accept(_DC node, TContext context);
            protected internal abstract TResult Accept(_DD node, TContext context);
            protected internal abstract TResult Accept(_DE node, TContext context);
            protected internal abstract TResult Accept(_DF node, TContext context);
            protected internal abstract TResult Accept(_E0 node, TContext context);
            protected internal abstract TResult Accept(_E1 node, TContext context);
            protected internal abstract TResult Accept(_E2 node, TContext context);
            protected internal abstract TResult Accept(_E3 node, TContext context);
            protected internal abstract TResult Accept(_E4 node, TContext context);
            protected internal abstract TResult Accept(_E5 node, TContext context);
            protected internal abstract TResult Accept(_E6 node, TContext context);
            protected internal abstract TResult Accept(_E7 node, TContext context);
            protected internal abstract TResult Accept(_E8 node, TContext context);
            protected internal abstract TResult Accept(_E9 node, TContext context);
            protected internal abstract TResult Accept(_EA node, TContext context);
            protected internal abstract TResult Accept(_EB node, TContext context);
            protected internal abstract TResult Accept(_EC node, TContext context);
            protected internal abstract TResult Accept(_ED node, TContext context);
            protected internal abstract TResult Accept(_EE node, TContext context);
            protected internal abstract TResult Accept(_EF node, TContext context);
            protected internal abstract TResult Accept(_F0 node, TContext context);
            protected internal abstract TResult Accept(_F1 node, TContext context);
            protected internal abstract TResult Accept(_F2 node, TContext context);
            protected internal abstract TResult Accept(_F3 node, TContext context);
            protected internal abstract TResult Accept(_F4 node, TContext context);
            protected internal abstract TResult Accept(_F5 node, TContext context);
            protected internal abstract TResult Accept(_F6 node, TContext context);
            protected internal abstract TResult Accept(_F7 node, TContext context);
            protected internal abstract TResult Accept(_F8 node, TContext context);
            protected internal abstract TResult Accept(_F9 node, TContext context);
            protected internal abstract TResult Accept(_FA node, TContext context);
            protected internal abstract TResult Accept(_FB node, TContext context);
            protected internal abstract TResult Accept(_FC node, TContext context);
            protected internal abstract TResult Accept(_FD node, TContext context);
            protected internal abstract TResult Accept(_FE node, TContext context);
            protected internal abstract TResult Accept(_FF node, TContext context);
        }
        
        public sealed class _00 : _Ⰳx00ⲻFFRealized
        {
            private _00(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._00>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._00> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._00> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._00>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._00>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._00(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._00>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _01 : _Ⰳx00ⲻFFRealized
        {
            private _01(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._01>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._01> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._01> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._01>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._01>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._01(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._01>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _02 : _Ⰳx00ⲻFFRealized
        {
            private _02(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._02>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._02> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._02> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._02>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._02>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._02(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._02>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _03 : _Ⰳx00ⲻFFRealized
        {
            private _03(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._03>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._03> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._03> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._03>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._03>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._03(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._03>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _04 : _Ⰳx00ⲻFFRealized
        {
            private _04(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._04>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._04> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._04> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._04>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._04>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._04(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._04>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _05 : _Ⰳx00ⲻFFRealized
        {
            private _05(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._05>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._05> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._05> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._05>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._05>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._05(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._05>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _06 : _Ⰳx00ⲻFFRealized
        {
            private _06(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._06>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._06> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._06> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._06>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._06>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._06(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._06>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _07 : _Ⰳx00ⲻFFRealized
        {
            private _07(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._07>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._07> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._07> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._07>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._07>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._07(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._07>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _08 : _Ⰳx00ⲻFFRealized
        {
            private _08(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._08>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._08> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._08> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._08>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._08>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._08(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._08>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _09 : _Ⰳx00ⲻFFRealized
        {
            private _09(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._09>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._09> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._09> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._09>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._09>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._09(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._09>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0A : _Ⰳx00ⲻFFRealized
        {
            private _0A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._0A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._0A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._0A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._0A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0B : _Ⰳx00ⲻFFRealized
        {
            private _0B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._0B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._0B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._0B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._0B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0C : _Ⰳx00ⲻFFRealized
        {
            private _0C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._0C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._0C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._0C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._0C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0D : _Ⰳx00ⲻFFRealized
        {
            private _0D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._0D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._0D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._0D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._0D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0E : _Ⰳx00ⲻFFRealized
        {
            private _0E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._0E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._0E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._0E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._0E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0F : _Ⰳx00ⲻFFRealized
        {
            private _0F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._0F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._0F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._0F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._0F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._0F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _10 : _Ⰳx00ⲻFFRealized
        {
            private _10(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._10>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._10> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._10> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._10>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._10>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._10(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._10>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _11 : _Ⰳx00ⲻFFRealized
        {
            private _11(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._11>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._11> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._11> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._11>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._11>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._11(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._11>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _12 : _Ⰳx00ⲻFFRealized
        {
            private _12(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._12>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._12> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._12> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._12>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._12>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._12(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._12>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _13 : _Ⰳx00ⲻFFRealized
        {
            private _13(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._13>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._13> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._13> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._13>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._13>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._13(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._13>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _14 : _Ⰳx00ⲻFFRealized
        {
            private _14(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._14>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._14> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._14> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._14>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._14>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._14(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._14>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _15 : _Ⰳx00ⲻFFRealized
        {
            private _15(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._15>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._15> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._15> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._15>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._15>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._15(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._15>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _16 : _Ⰳx00ⲻFFRealized
        {
            private _16(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._16>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._16> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._16> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._16>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._16>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._16(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._16>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _17 : _Ⰳx00ⲻFFRealized
        {
            private _17(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._17>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._17> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._17> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._17>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._17>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._17(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._17>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _18 : _Ⰳx00ⲻFFRealized
        {
            private _18(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._18>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._18> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._18> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._18>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._18>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._18(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._18>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _19 : _Ⰳx00ⲻFFRealized
        {
            private _19(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._19>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._19> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._19> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._19>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._19>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._19(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._19>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1A : _Ⰳx00ⲻFFRealized
        {
            private _1A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._1A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._1A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._1A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._1A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1B : _Ⰳx00ⲻFFRealized
        {
            private _1B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._1B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._1B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._1B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._1B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1C : _Ⰳx00ⲻFFRealized
        {
            private _1C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._1C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._1C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._1C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._1C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1D : _Ⰳx00ⲻFFRealized
        {
            private _1D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._1D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._1D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._1D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._1D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1E : _Ⰳx00ⲻFFRealized
        {
            private _1E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._1E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._1E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._1E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._1E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1F : _Ⰳx00ⲻFFRealized
        {
            private _1F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._1F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._1F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._1F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._1F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._1F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _20 : _Ⰳx00ⲻFFRealized
        {
            private _20(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._20>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._20> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._20> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._20>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._20>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._20(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._20>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _21 : _Ⰳx00ⲻFFRealized
        {
            private _21(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._21>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._21> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._21> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._21>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._21>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._21(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._21>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _22 : _Ⰳx00ⲻFFRealized
        {
            private _22(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._22>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._22> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._22> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._22>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._22>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._22(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._22>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _23 : _Ⰳx00ⲻFFRealized
        {
            private _23(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._23>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._23> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._23> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._23>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._23>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._23(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._23>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _24 : _Ⰳx00ⲻFFRealized
        {
            private _24(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._24>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._24> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._24> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._24>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._24>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._24(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._24>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _25 : _Ⰳx00ⲻFFRealized
        {
            private _25(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._25>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._25> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._25> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._25>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._25>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._25(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._25>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _26 : _Ⰳx00ⲻFFRealized
        {
            private _26(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._26>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._26> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._26> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._26>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._26>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._26(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._26>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _27 : _Ⰳx00ⲻFFRealized
        {
            private _27(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._27>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._27> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._27> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._27>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._27>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._27(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._27>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _28 : _Ⰳx00ⲻFFRealized
        {
            private _28(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._28>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._28> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._28> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._28>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._28>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._28(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._28>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _29 : _Ⰳx00ⲻFFRealized
        {
            private _29(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._29>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._29> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._29> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._29>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._29>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._29(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._29>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2A : _Ⰳx00ⲻFFRealized
        {
            private _2A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._2A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._2A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._2A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._2A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2B : _Ⰳx00ⲻFFRealized
        {
            private _2B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._2B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._2B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._2B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._2B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2C : _Ⰳx00ⲻFFRealized
        {
            private _2C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._2C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._2C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._2C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._2C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2D : _Ⰳx00ⲻFFRealized
        {
            private _2D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._2D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._2D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._2D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._2D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2E : _Ⰳx00ⲻFFRealized
        {
            private _2E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._2E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._2E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._2E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._2E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2F : _Ⰳx00ⲻFFRealized
        {
            private _2F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._2F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._2F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._2F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._2F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._2F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _30 : _Ⰳx00ⲻFFRealized
        {
            private _30(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._30>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._30> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._30> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._30>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._30>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._30(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._30>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _31 : _Ⰳx00ⲻFFRealized
        {
            private _31(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._31>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._31> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._31> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._31>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._31>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._31(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._31>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _32 : _Ⰳx00ⲻFFRealized
        {
            private _32(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._32>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._32> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._32> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._32>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._32>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._32(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._32>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _33 : _Ⰳx00ⲻFFRealized
        {
            private _33(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._33>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._33> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._33> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._33>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._33>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._33(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._33>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _34 : _Ⰳx00ⲻFFRealized
        {
            private _34(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._34>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._34> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._34> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._34>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._34>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._34(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._34>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _35 : _Ⰳx00ⲻFFRealized
        {
            private _35(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._35>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._35> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._35> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._35>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._35>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._35(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._35>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _36 : _Ⰳx00ⲻFFRealized
        {
            private _36(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._36>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._36> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._36> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._36>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._36>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._36(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._36>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _37 : _Ⰳx00ⲻFFRealized
        {
            private _37(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._37>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._37> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._37> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._37>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._37>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._37(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._37>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _38 : _Ⰳx00ⲻFFRealized
        {
            private _38(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._38>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._38> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._38> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._38>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._38>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._38(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._38>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _39 : _Ⰳx00ⲻFFRealized
        {
            private _39(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._39>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._39> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._39> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._39>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._39>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._39(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._39>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3A : _Ⰳx00ⲻFFRealized
        {
            private _3A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._3A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._3A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._3A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._3A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3B : _Ⰳx00ⲻFFRealized
        {
            private _3B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._3B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._3B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._3B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._3B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3C : _Ⰳx00ⲻFFRealized
        {
            private _3C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._3C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._3C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._3C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._3C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3D : _Ⰳx00ⲻFFRealized
        {
            private _3D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._3D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._3D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._3D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._3D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3E : _Ⰳx00ⲻFFRealized
        {
            private _3E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._3E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._3E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._3E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._3E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3F : _Ⰳx00ⲻFFRealized
        {
            private _3F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._3F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._3F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._3F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._3F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._3F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _40 : _Ⰳx00ⲻFFRealized
        {
            private _40(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._40>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._40> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._40> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._40>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._40>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._40(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._40>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _41 : _Ⰳx00ⲻFFRealized
        {
            private _41(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._41>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._41> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._41> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._41>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._41>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._41(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._41>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _42 : _Ⰳx00ⲻFFRealized
        {
            private _42(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._42>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._42> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._42> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._42>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._42>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._42(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._42>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _43 : _Ⰳx00ⲻFFRealized
        {
            private _43(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._43>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._43> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._43> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._43>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._43>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._43(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._43>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _44 : _Ⰳx00ⲻFFRealized
        {
            private _44(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._44>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._44> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._44> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._44>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._44>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._44(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._44>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _45 : _Ⰳx00ⲻFFRealized
        {
            private _45(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._45>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._45> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._45> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._45>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._45>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._45(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._45>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _46 : _Ⰳx00ⲻFFRealized
        {
            private _46(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._46>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._46> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._46> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._46>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._46>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._46(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._46>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _47 : _Ⰳx00ⲻFFRealized
        {
            private _47(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._47>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._47> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._47> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._47>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._47>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._47(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._47>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _48 : _Ⰳx00ⲻFFRealized
        {
            private _48(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._48>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._48> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._48> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._48>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._48>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._48(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._48>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _49 : _Ⰳx00ⲻFFRealized
        {
            private _49(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._49>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._49> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._49> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._49>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._49>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._49(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._49>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4A : _Ⰳx00ⲻFFRealized
        {
            private _4A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._4A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._4A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._4A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._4A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4B : _Ⰳx00ⲻFFRealized
        {
            private _4B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._4B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._4B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._4B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._4B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4C : _Ⰳx00ⲻFFRealized
        {
            private _4C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._4C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._4C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._4C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._4C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4D : _Ⰳx00ⲻFFRealized
        {
            private _4D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._4D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._4D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._4D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._4D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4E : _Ⰳx00ⲻFFRealized
        {
            private _4E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._4E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._4E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._4E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._4E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4F : _Ⰳx00ⲻFFRealized
        {
            private _4F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._4F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._4F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._4F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._4F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._4F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _50 : _Ⰳx00ⲻFFRealized
        {
            private _50(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._50>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._50> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._50> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._50>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._50>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._50(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._50>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _51 : _Ⰳx00ⲻFFRealized
        {
            private _51(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._51>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._51> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._51> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._51>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._51>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._51(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._51>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _52 : _Ⰳx00ⲻFFRealized
        {
            private _52(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._52>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._52> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._52> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._52>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._52>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._52(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._52>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _53 : _Ⰳx00ⲻFFRealized
        {
            private _53(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._53>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._53> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._53> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._53>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._53>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._53(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._53>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _54 : _Ⰳx00ⲻFFRealized
        {
            private _54(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._54>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._54> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._54> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._54>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._54>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._54(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._54>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _55 : _Ⰳx00ⲻFFRealized
        {
            private _55(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._55>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._55> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._55> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._55>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._55>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._55(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._55>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _56 : _Ⰳx00ⲻFFRealized
        {
            private _56(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._56>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._56> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._56> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._56>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._56>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._56(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._56>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _57 : _Ⰳx00ⲻFFRealized
        {
            private _57(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._57>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._57> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._57> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._57>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._57>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._57(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._57>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _58 : _Ⰳx00ⲻFFRealized
        {
            private _58(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._58>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._58> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._58> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._58>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._58>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._58(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._58>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _59 : _Ⰳx00ⲻFFRealized
        {
            private _59(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._59>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._59> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._59> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._59>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._59>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._59(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._59>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5A : _Ⰳx00ⲻFFRealized
        {
            private _5A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._5A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._5A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._5A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._5A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5B : _Ⰳx00ⲻFFRealized
        {
            private _5B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._5B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._5B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._5B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._5B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5C : _Ⰳx00ⲻFFRealized
        {
            private _5C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._5C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._5C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._5C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._5C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5D : _Ⰳx00ⲻFFRealized
        {
            private _5D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._5D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._5D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._5D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._5D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5E : _Ⰳx00ⲻFFRealized
        {
            private _5E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._5E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._5E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._5E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._5E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5F : _Ⰳx00ⲻFFRealized
        {
            private _5F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._5F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._5F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._5F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._5F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._5F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _60 : _Ⰳx00ⲻFFRealized
        {
            private _60(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._60>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._60> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._60> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._60>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._60>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._60(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._60>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _61 : _Ⰳx00ⲻFFRealized
        {
            private _61(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._61>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._61> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._61> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._61>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._61>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._61(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._61>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _62 : _Ⰳx00ⲻFFRealized
        {
            private _62(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._62>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._62> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._62> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._62>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._62>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._62(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._62>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _63 : _Ⰳx00ⲻFFRealized
        {
            private _63(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._63>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._63> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._63> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._63>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._63>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._63(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._63>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _64 : _Ⰳx00ⲻFFRealized
        {
            private _64(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._64>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._64> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._64> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._64>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._64>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._64(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._64>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _65 : _Ⰳx00ⲻFFRealized
        {
            private _65(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._65>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._65> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._65> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._65>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._65>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._65(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._65>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _66 : _Ⰳx00ⲻFFRealized
        {
            private _66(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._66>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._66> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._66> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._66>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._66>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._66(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._66>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _67 : _Ⰳx00ⲻFFRealized
        {
            private _67(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._67>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._67> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._67> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._67>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._67>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._67(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._67>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _68 : _Ⰳx00ⲻFFRealized
        {
            private _68(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._68>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._68> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._68> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._68>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._68>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._68(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._68>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _69 : _Ⰳx00ⲻFFRealized
        {
            private _69(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._69>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._69> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._69> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._69>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._69>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._69(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._69>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6A : _Ⰳx00ⲻFFRealized
        {
            private _6A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._6A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._6A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._6A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._6A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6B : _Ⰳx00ⲻFFRealized
        {
            private _6B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._6B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._6B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._6B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._6B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6C : _Ⰳx00ⲻFFRealized
        {
            private _6C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._6C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._6C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._6C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._6C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6D : _Ⰳx00ⲻFFRealized
        {
            private _6D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._6D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._6D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._6D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._6D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6E : _Ⰳx00ⲻFFRealized
        {
            private _6E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._6E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._6E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._6E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._6E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6F : _Ⰳx00ⲻFFRealized
        {
            private _6F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._6F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._6F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._6F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._6F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._6F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _70 : _Ⰳx00ⲻFFRealized
        {
            private _70(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._70>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._70> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._70> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._70>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._70>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._70(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._70>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _71 : _Ⰳx00ⲻFFRealized
        {
            private _71(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._71>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._71> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._71> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._71>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._71>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._71(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._71>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _72 : _Ⰳx00ⲻFFRealized
        {
            private _72(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._72>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._72> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._72> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._72>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._72>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._72(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._72>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _73 : _Ⰳx00ⲻFFRealized
        {
            private _73(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._73>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._73> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._73> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._73>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._73>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._73(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._73>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _74 : _Ⰳx00ⲻFFRealized
        {
            private _74(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._74>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._74> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._74> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._74>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._74>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._74(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._74>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _75 : _Ⰳx00ⲻFFRealized
        {
            private _75(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._75>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._75> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._75> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._75>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._75>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._75(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._75>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _76 : _Ⰳx00ⲻFFRealized
        {
            private _76(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._76>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._76> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._76> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._76>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._76>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._76(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._76>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _77 : _Ⰳx00ⲻFFRealized
        {
            private _77(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._77>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._77> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._77> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._77>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._77>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._77(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._77>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _78 : _Ⰳx00ⲻFFRealized
        {
            private _78(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._78>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._78> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._78> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._78>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._78>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._78(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._78>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _79 : _Ⰳx00ⲻFFRealized
        {
            private _79(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._79>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._79> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._79> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._79>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._79>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._79(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._79>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7A : _Ⰳx00ⲻFFRealized
        {
            private _7A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._7A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._7A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._7A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._7A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7B : _Ⰳx00ⲻFFRealized
        {
            private _7B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._7B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._7B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._7B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._7B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7C : _Ⰳx00ⲻFFRealized
        {
            private _7C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._7C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._7C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._7C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._7C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7D : _Ⰳx00ⲻFFRealized
        {
            private _7D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._7D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._7D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._7D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._7D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7E : _Ⰳx00ⲻFFRealized
        {
            private _7E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._7E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._7E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._7E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._7E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7F : _Ⰳx00ⲻFFRealized
        {
            private _7F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._7F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._7F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._7F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._7F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._7F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _80 : _Ⰳx00ⲻFFRealized
        {
            private _80(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._80>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._80> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._80> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._80>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._80>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._80(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._80>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _81 : _Ⰳx00ⲻFFRealized
        {
            private _81(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._81>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._81> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._81> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._81>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._81>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._81(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._81>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _82 : _Ⰳx00ⲻFFRealized
        {
            private _82(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._82>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._82> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._82> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._82>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._82>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._82(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._82>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _83 : _Ⰳx00ⲻFFRealized
        {
            private _83(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._83>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._83> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._83> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._83>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._83>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._83(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._83>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _84 : _Ⰳx00ⲻFFRealized
        {
            private _84(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._84>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._84> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._84> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._84>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._84>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._84(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._84>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _85 : _Ⰳx00ⲻFFRealized
        {
            private _85(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._85>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._85> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._85> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._85>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._85>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._85(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._85>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _86 : _Ⰳx00ⲻFFRealized
        {
            private _86(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._86>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._86> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._86> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._86>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._86>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._86(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._86>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _87 : _Ⰳx00ⲻFFRealized
        {
            private _87(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._87>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._87> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._87> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._87>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._87>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._87(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._87>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _88 : _Ⰳx00ⲻFFRealized
        {
            private _88(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._88>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._88> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._88> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._88>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._88>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._88(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._88>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _89 : _Ⰳx00ⲻFFRealized
        {
            private _89(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._89>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._89> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._89> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._89>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._89>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._89(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._89>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _8A : _Ⰳx00ⲻFFRealized
        {
            private _8A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._8A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._8A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._8A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._8A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _8B : _Ⰳx00ⲻFFRealized
        {
            private _8B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._8B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._8B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._8B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._8B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _8C : _Ⰳx00ⲻFFRealized
        {
            private _8C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._8C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._8C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._8C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._8C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _8D : _Ⰳx00ⲻFFRealized
        {
            private _8D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._8D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._8D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._8D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._8D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _8E : _Ⰳx00ⲻFFRealized
        {
            private _8E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._8E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._8E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._8E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._8E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _8F : _Ⰳx00ⲻFFRealized
        {
            private _8F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._8F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._8F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._8F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._8F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._8F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _90 : _Ⰳx00ⲻFFRealized
        {
            private _90(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._90>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._90> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._90> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._90>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._90>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._90(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._90>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _91 : _Ⰳx00ⲻFFRealized
        {
            private _91(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._91>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._91> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._91> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._91>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._91>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._91(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._91>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _92 : _Ⰳx00ⲻFFRealized
        {
            private _92(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._92>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._92> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._92> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._92>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._92>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._92(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._92>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _93 : _Ⰳx00ⲻFFRealized
        {
            private _93(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._93>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._93> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._93> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._93>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._93>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._93(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._93>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _94 : _Ⰳx00ⲻFFRealized
        {
            private _94(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._94>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._94> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._94> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._94>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._94>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._94(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._94>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _95 : _Ⰳx00ⲻFFRealized
        {
            private _95(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._95>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._95> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._95> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._95>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._95>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._95(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._95>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _96 : _Ⰳx00ⲻFFRealized
        {
            private _96(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._96>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._96> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._96> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._96>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._96>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._96(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._96>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _97 : _Ⰳx00ⲻFFRealized
        {
            private _97(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._97>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._97> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._97> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._97>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._97>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._97(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._97>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _98 : _Ⰳx00ⲻFFRealized
        {
            private _98(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._98>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._98> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._98> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._98>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._98>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._98(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._98>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _99 : _Ⰳx00ⲻFFRealized
        {
            private _99(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._99>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._99> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._99> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._99>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._99>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._99(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._99>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _9A : _Ⰳx00ⲻFFRealized
        {
            private _9A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._9A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._9A> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._9A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._9A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9A>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _9B : _Ⰳx00ⲻFFRealized
        {
            private _9B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._9B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._9B> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._9B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._9B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9B>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _9C : _Ⰳx00ⲻFFRealized
        {
            private _9C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._9C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._9C> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._9C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._9C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9C>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _9D : _Ⰳx00ⲻFFRealized
        {
            private _9D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._9D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._9D> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._9D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._9D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9D>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _9E : _Ⰳx00ⲻFFRealized
        {
            private _9E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._9E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._9E> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._9E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._9E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9E>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _9F : _Ⰳx00ⲻFFRealized
        {
            private _9F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._9F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._9F> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._9F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._9F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._9F>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A0 : _Ⰳx00ⲻFFRealized
        {
            private _A0(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A0>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A0> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A0> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A0>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A0>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A0(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A0>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A1 : _Ⰳx00ⲻFFRealized
        {
            private _A1(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A1>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A1> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A1> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A1>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A1>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A1(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A1>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A2 : _Ⰳx00ⲻFFRealized
        {
            private _A2(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A2>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A2> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A2> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A2>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A2>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A2(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A2>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A3 : _Ⰳx00ⲻFFRealized
        {
            private _A3(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A3>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A3> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A3> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A3>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A3>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A3(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A3>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A4 : _Ⰳx00ⲻFFRealized
        {
            private _A4(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A4>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A4> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A4> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A4>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A4>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A4(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A4>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A5 : _Ⰳx00ⲻFFRealized
        {
            private _A5(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A5>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A5> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A5> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A5>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A5>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A5(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A5>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A6 : _Ⰳx00ⲻFFRealized
        {
            private _A6(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A6>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A6> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A6> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A6>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A6>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A6(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A6>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A7 : _Ⰳx00ⲻFFRealized
        {
            private _A7(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A7>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A7> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A7> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A7>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A7>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A7(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A7>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A8 : _Ⰳx00ⲻFFRealized
        {
            private _A8(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A8>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A8> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A8> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A8>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A8>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A8(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A8>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _A9 : _Ⰳx00ⲻFFRealized
        {
            private _A9(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._A9>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._A9> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._A9> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A9>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A9>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._A9(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._A9>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _AA : _Ⰳx00ⲻFFRealized
        {
            private _AA(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._AA>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._AA> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._AA> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AA>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AA>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._AA(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AA>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _AB : _Ⰳx00ⲻFFRealized
        {
            private _AB(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._AB>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._AB> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._AB> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AB>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AB>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._AB(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AB>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _AC : _Ⰳx00ⲻFFRealized
        {
            private _AC(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._AC>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._AC> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._AC> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AC>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AC>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._AC(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AC>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _AD : _Ⰳx00ⲻFFRealized
        {
            private _AD(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._AD>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._AD> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._AD> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AD>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AD>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._AD(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AD>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _AE : _Ⰳx00ⲻFFRealized
        {
            private _AE(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._AE>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._AE> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._AE> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AE>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AE>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._AE(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AE>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _AF : _Ⰳx00ⲻFFRealized
        {
            private _AF(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._AF>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._AF> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._AF> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AF>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AF>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._AF(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._AF>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B0 : _Ⰳx00ⲻFFRealized
        {
            private _B0(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B0>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B0> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B0> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B0>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B0>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B0(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B0>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B1 : _Ⰳx00ⲻFFRealized
        {
            private _B1(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B1>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B1> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B1> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B1>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B1>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B1(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B1>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B2 : _Ⰳx00ⲻFFRealized
        {
            private _B2(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B2>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B2> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B2> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B2>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B2>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B2(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B2>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B3 : _Ⰳx00ⲻFFRealized
        {
            private _B3(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B3>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B3> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B3> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B3>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B3>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B3(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B3>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B4 : _Ⰳx00ⲻFFRealized
        {
            private _B4(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B4>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B4> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B4> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B4>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B4>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B4(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B4>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B5 : _Ⰳx00ⲻFFRealized
        {
            private _B5(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B5>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B5> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B5> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B5>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B5>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B5(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B5>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B6 : _Ⰳx00ⲻFFRealized
        {
            private _B6(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B6>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B6> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B6> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B6>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B6>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B6(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B6>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B7 : _Ⰳx00ⲻFFRealized
        {
            private _B7(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B7>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B7> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B7> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B7>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B7>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B7(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B7>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B8 : _Ⰳx00ⲻFFRealized
        {
            private _B8(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B8>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B8> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B8> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B8>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B8>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B8(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B8>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _B9 : _Ⰳx00ⲻFFRealized
        {
            private _B9(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._B9>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._B9> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._B9> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B9>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B9>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._B9(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._B9>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _BA : _Ⰳx00ⲻFFRealized
        {
            private _BA(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._BA>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._BA> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._BA> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BA>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BA>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._BA(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BA>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _BB : _Ⰳx00ⲻFFRealized
        {
            private _BB(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._BB>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._BB> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._BB> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BB>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BB>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._BB(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BB>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _BC : _Ⰳx00ⲻFFRealized
        {
            private _BC(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._BC>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._BC> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._BC> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BC>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BC>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._BC(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BC>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _BD : _Ⰳx00ⲻFFRealized
        {
            private _BD(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._BD>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._BD> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._BD> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BD>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BD>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._BD(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BD>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _BE : _Ⰳx00ⲻFFRealized
        {
            private _BE(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._BE>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._BE> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._BE> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BE>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BE>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._BE(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BE>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _BF : _Ⰳx00ⲻFFRealized
        {
            private _BF(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._BF>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._BF> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._BF> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BF>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BF>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._BF(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._BF>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C0 : _Ⰳx00ⲻFFRealized
        {
            private _C0(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C0>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C0> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C0> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C0>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C0>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C0(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C0>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C1 : _Ⰳx00ⲻFFRealized
        {
            private _C1(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C1>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C1> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C1> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C1>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C1>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C1(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C1>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C2 : _Ⰳx00ⲻFFRealized
        {
            private _C2(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C2>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C2> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C2> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C2>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C2>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C2(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C2>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C3 : _Ⰳx00ⲻFFRealized
        {
            private _C3(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C3>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C3> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C3> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C3>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C3>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C3(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C3>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C4 : _Ⰳx00ⲻFFRealized
        {
            private _C4(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C4>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C4> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C4> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C4>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C4>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C4(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C4>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C5 : _Ⰳx00ⲻFFRealized
        {
            private _C5(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C5>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C5> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C5> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C5>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C5>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C5(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C5>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C6 : _Ⰳx00ⲻFFRealized
        {
            private _C6(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C6>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C6> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C6> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C6>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C6>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C6(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C6>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C7 : _Ⰳx00ⲻFFRealized
        {
            private _C7(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C7>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C7> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C7> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C7>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C7>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C7(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C7>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C8 : _Ⰳx00ⲻFFRealized
        {
            private _C8(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C8>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C8> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C8> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C8>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C8>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C8(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C8>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _C9 : _Ⰳx00ⲻFFRealized
        {
            private _C9(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._C9>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._C9> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._C9> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C9>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C9>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._C9(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._C9>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _CA : _Ⰳx00ⲻFFRealized
        {
            private _CA(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._CA>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._CA> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._CA> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CA>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CA>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._CA(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CA>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _CB : _Ⰳx00ⲻFFRealized
        {
            private _CB(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._CB>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._CB> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._CB> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CB>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CB>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._CB(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CB>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _CC : _Ⰳx00ⲻFFRealized
        {
            private _CC(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._CC>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._CC> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._CC> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CC>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CC>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._CC(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CC>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _CD : _Ⰳx00ⲻFFRealized
        {
            private _CD(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._CD>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._CD> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._CD> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CD>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CD>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._CD(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CD>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _CE : _Ⰳx00ⲻFFRealized
        {
            private _CE(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._CE>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._CE> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._CE> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CE>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CE>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._CE(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CE>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _CF : _Ⰳx00ⲻFFRealized
        {
            private _CF(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._CF>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._CF> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._CF> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CF>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CF>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._CF(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._CF>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D0 : _Ⰳx00ⲻFFRealized
        {
            private _D0(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D0>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D0> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D0> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D0>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D0>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D0(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D0>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D1 : _Ⰳx00ⲻFFRealized
        {
            private _D1(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D1>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D1> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D1> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D1>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D1>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D1(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D1>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D2 : _Ⰳx00ⲻFFRealized
        {
            private _D2(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D2>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D2> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D2> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D2>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D2>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D2(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D2>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D3 : _Ⰳx00ⲻFFRealized
        {
            private _D3(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D3>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D3> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D3> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D3>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D3>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D3(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D3>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D4 : _Ⰳx00ⲻFFRealized
        {
            private _D4(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D4>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D4> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D4> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D4>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D4>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D4(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D4>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D5 : _Ⰳx00ⲻFFRealized
        {
            private _D5(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D5>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D5> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D5> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D5>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D5>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D5(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D5>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D6 : _Ⰳx00ⲻFFRealized
        {
            private _D6(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D6>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D6> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D6> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D6>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D6>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D6(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D6>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D7 : _Ⰳx00ⲻFFRealized
        {
            private _D7(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D7>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D7> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D7> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D7>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D7>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D7(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D7>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D8 : _Ⰳx00ⲻFFRealized
        {
            private _D8(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D8>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D8> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D8> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D8>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D8>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D8(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D8>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _D9 : _Ⰳx00ⲻFFRealized
        {
            private _D9(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._D9>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._D9> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._D9> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D9>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D9>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._D9(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._D9>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _DA : _Ⰳx00ⲻFFRealized
        {
            private _DA(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._DA>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._DA> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._DA> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DA>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DA>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._DA(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DA>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _DB : _Ⰳx00ⲻFFRealized
        {
            private _DB(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._DB>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._DB> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._DB> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DB>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DB>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._DB(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DB>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _DC : _Ⰳx00ⲻFFRealized
        {
            private _DC(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._DC>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._DC> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._DC> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DC>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DC>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._DC(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DC>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _DD : _Ⰳx00ⲻFFRealized
        {
            private _DD(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._DD>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._DD> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._DD> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DD>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DD>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._DD(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DD>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _DE : _Ⰳx00ⲻFFRealized
        {
            private _DE(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._DE>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._DE> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._DE> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DE>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DE>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._DE(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DE>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _DF : _Ⰳx00ⲻFFRealized
        {
            private _DF(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._DF>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._DF> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._DF> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DF>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DF>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._DF(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._DF>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E0 : _Ⰳx00ⲻFFRealized
        {
            private _E0(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E0>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E0> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E0> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E0>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E0>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E0(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E0>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E1 : _Ⰳx00ⲻFFRealized
        {
            private _E1(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E1>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E1> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E1> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E1>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E1>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E1(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E1>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E2 : _Ⰳx00ⲻFFRealized
        {
            private _E2(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E2>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E2> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E2> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E2>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E2>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E2(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E2>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E3 : _Ⰳx00ⲻFFRealized
        {
            private _E3(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E3>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E3> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E3> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E3>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E3>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E3(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E3>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E4 : _Ⰳx00ⲻFFRealized
        {
            private _E4(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E4>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E4> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E4> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E4>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E4>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E4(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E4>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E5 : _Ⰳx00ⲻFFRealized
        {
            private _E5(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E5>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E5> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E5> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E5>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E5>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E5(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E5>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E6 : _Ⰳx00ⲻFFRealized
        {
            private _E6(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E6>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E6> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E6> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E6>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E6>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E6(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E6>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E7 : _Ⰳx00ⲻFFRealized
        {
            private _E7(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E7>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E7> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E7> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E7>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E7>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E7(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E7>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E8 : _Ⰳx00ⲻFFRealized
        {
            private _E8(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E8>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E8> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E8> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E8>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E8>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E8(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E8>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _E9 : _Ⰳx00ⲻFFRealized
        {
            private _E9(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._E9>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._E9> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._E9> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E9>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E9>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._E9(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._E9>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _EA : _Ⰳx00ⲻFFRealized
        {
            private _EA(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._EA>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._EA> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._EA> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EA>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EA>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._EA(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EA>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _EB : _Ⰳx00ⲻFFRealized
        {
            private _EB(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._EB>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._EB> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._EB> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EB>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EB>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._EB(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EB>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _EC : _Ⰳx00ⲻFFRealized
        {
            private _EC(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._EC>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._EC> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._EC> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EC>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EC>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._EC(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EC>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _ED : _Ⰳx00ⲻFFRealized
        {
            private _ED(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._ED>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._ED> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._ED> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._ED>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._ED>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._ED(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._ED>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _EE : _Ⰳx00ⲻFFRealized
        {
            private _EE(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._EE>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._EE> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._EE> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EE>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EE>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._EE(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EE>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _EF : _Ⰳx00ⲻFFRealized
        {
            private _EF(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._EF>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._EF> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._EF> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EF>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EF>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._EF(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._EF>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F0 : _Ⰳx00ⲻFFRealized
        {
            private _F0(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F0>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F0> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._0<ParseMode.Realized> _0_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F0> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F0>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F0>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F0(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F0>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F1 : _Ⰳx00ⲻFFRealized
        {
            private _F1(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F1>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F1> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._1<ParseMode.Realized> _1_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F1> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F1>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F1>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F1(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F1>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F2 : _Ⰳx00ⲻFFRealized
        {
            private _F2(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F2>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F2> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._2<ParseMode.Realized> _2_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F2> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F2>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F2>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F2(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F2>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F3 : _Ⰳx00ⲻFFRealized
        {
            private _F3(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F3>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F3> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._3<ParseMode.Realized> _3_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F3> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F3>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F3>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F3(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F3>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F4 : _Ⰳx00ⲻFFRealized
        {
            private _F4(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F4>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F4> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._4<ParseMode.Realized> _4_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F4> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F4>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F4>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F4(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F4>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F5 : _Ⰳx00ⲻFFRealized
        {
            private _F5(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F5>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F5> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._5<ParseMode.Realized> _5_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F5> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F5>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F5>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F5(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F5>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F6 : _Ⰳx00ⲻFFRealized
        {
            private _F6(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F6>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F6> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._6<ParseMode.Realized> _6_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F6> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F6>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F6>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F6(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F6>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F7 : _Ⰳx00ⲻFFRealized
        {
            private _F7(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F7>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F7> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._7<ParseMode.Realized> _7_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F7> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F7>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F7>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F7(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F7>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F8 : _Ⰳx00ⲻFFRealized
        {
            private _F8(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F8>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F8> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._8<ParseMode.Realized> _8_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F8> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F8>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F8>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F8(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F8>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _F9 : _Ⰳx00ⲻFFRealized
        {
            private _F9(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._F9>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._F9> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._9<ParseMode.Realized> _9_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._F9> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F9>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F9>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._F9(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._F9>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _FA : _Ⰳx00ⲻFFRealized
        {
            private _FA(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._FA>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._FA> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._A<ParseMode.Realized> _A_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._FA> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FA>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FA>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._FA(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FA>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _FB : _Ⰳx00ⲻFFRealized
        {
            private _FB(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._FB>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._FB> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._B<ParseMode.Realized> _B_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._FB> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FB>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FB>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._FB(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FB>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _FC : _Ⰳx00ⲻFFRealized
        {
            private _FC(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._FC>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._FC> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._C<ParseMode.Realized> _C_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._FC> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FC>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FC>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._FC(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FC>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _FD : _Ⰳx00ⲻFFRealized
        {
            private _FD(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._FD>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._FD> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._D<ParseMode.Realized> _D_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._FD> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FD>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FD>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._FD(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FD>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _FE : _Ⰳx00ⲻFFRealized
        {
            private _FE(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._FE>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._FE> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._E<ParseMode.Realized> _E_1 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._FE> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FE>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FE>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._FE(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FE>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _FF : _Ⰳx00ⲻFFRealized
        {
            private _FF(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx00ⲻFFRealized._FF>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx00ⲻFFRealized._FF> RealizationResult { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_1 { get; }
            public __GeneratedPartialV1.Deferred.CstNodes.Inners._F<ParseMode.Realized> _F_2 { get; }
            
            public static IRealizationResult<char, _Ⰳx00ⲻFFRealized._FF> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FF>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FF>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx00ⲻFFRealized._FF(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx00ⲻFFRealized._FF>(false, default, input);
}
            }
            
            public override _Ⰳx00ⲻFFDeferred Convert()
            {
                return new _Ⰳx00ⲻFFDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
    }
    
}
