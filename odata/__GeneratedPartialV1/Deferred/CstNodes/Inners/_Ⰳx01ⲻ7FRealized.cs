namespace __GeneratedPartialV1.Deferred.CstNodes.Inners
{
    using System;
    using CombinatorParsingV3;
    
    public abstract class _Ⰳx01ⲻ7FRealized : IFromRealizedable<_Ⰳx01ⲻ7FDeferred>
    {
        private _Ⰳx01ⲻ7FRealized()
        {
        }
        
        public abstract _Ⰳx01ⲻ7FDeferred Convert();
        protected abstract TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context);
        
        public abstract class Visitor<TResult, TContext>
        {
            public TResult Visit(_Ⰳx01ⲻ7FRealized node, TContext context)
            {
                return node.Dispatch(this, context);
            }
            
            protected internal abstract TResult Accept(_01 node, TContext context);
            protected internal abstract TResult Accept(_02 node, TContext context);
            protected internal abstract TResult Accept(_03 node, TContext context);
            protected internal abstract TResult Accept(_04 node, TContext context);
            protected internal abstract TResult Accept(_05 node, TContext context);
            protected internal abstract TResult Accept(_06 node, TContext context);
            protected internal abstract TResult Accept(_07 node, TContext context);
            protected internal abstract TResult Accept(_08 node, TContext context);
            protected internal abstract TResult Accept(_09 node, TContext context);
            protected internal abstract TResult Accept(_0A node, TContext context);
            protected internal abstract TResult Accept(_0B node, TContext context);
            protected internal abstract TResult Accept(_0C node, TContext context);
            protected internal abstract TResult Accept(_0D node, TContext context);
            protected internal abstract TResult Accept(_0E node, TContext context);
            protected internal abstract TResult Accept(_0F node, TContext context);
            protected internal abstract TResult Accept(_10 node, TContext context);
            protected internal abstract TResult Accept(_11 node, TContext context);
            protected internal abstract TResult Accept(_12 node, TContext context);
            protected internal abstract TResult Accept(_13 node, TContext context);
            protected internal abstract TResult Accept(_14 node, TContext context);
            protected internal abstract TResult Accept(_15 node, TContext context);
            protected internal abstract TResult Accept(_16 node, TContext context);
            protected internal abstract TResult Accept(_17 node, TContext context);
            protected internal abstract TResult Accept(_18 node, TContext context);
            protected internal abstract TResult Accept(_19 node, TContext context);
            protected internal abstract TResult Accept(_1A node, TContext context);
            protected internal abstract TResult Accept(_1B node, TContext context);
            protected internal abstract TResult Accept(_1C node, TContext context);
            protected internal abstract TResult Accept(_1D node, TContext context);
            protected internal abstract TResult Accept(_1E node, TContext context);
            protected internal abstract TResult Accept(_1F node, TContext context);
            protected internal abstract TResult Accept(_20 node, TContext context);
            protected internal abstract TResult Accept(_21 node, TContext context);
            protected internal abstract TResult Accept(_22 node, TContext context);
            protected internal abstract TResult Accept(_23 node, TContext context);
            protected internal abstract TResult Accept(_24 node, TContext context);
            protected internal abstract TResult Accept(_25 node, TContext context);
            protected internal abstract TResult Accept(_26 node, TContext context);
            protected internal abstract TResult Accept(_27 node, TContext context);
            protected internal abstract TResult Accept(_28 node, TContext context);
            protected internal abstract TResult Accept(_29 node, TContext context);
            protected internal abstract TResult Accept(_2A node, TContext context);
            protected internal abstract TResult Accept(_2B node, TContext context);
            protected internal abstract TResult Accept(_2C node, TContext context);
            protected internal abstract TResult Accept(_2D node, TContext context);
            protected internal abstract TResult Accept(_2E node, TContext context);
            protected internal abstract TResult Accept(_2F node, TContext context);
            protected internal abstract TResult Accept(_30 node, TContext context);
            protected internal abstract TResult Accept(_31 node, TContext context);
            protected internal abstract TResult Accept(_32 node, TContext context);
            protected internal abstract TResult Accept(_33 node, TContext context);
            protected internal abstract TResult Accept(_34 node, TContext context);
            protected internal abstract TResult Accept(_35 node, TContext context);
            protected internal abstract TResult Accept(_36 node, TContext context);
            protected internal abstract TResult Accept(_37 node, TContext context);
            protected internal abstract TResult Accept(_38 node, TContext context);
            protected internal abstract TResult Accept(_39 node, TContext context);
            protected internal abstract TResult Accept(_3A node, TContext context);
            protected internal abstract TResult Accept(_3B node, TContext context);
            protected internal abstract TResult Accept(_3C node, TContext context);
            protected internal abstract TResult Accept(_3D node, TContext context);
            protected internal abstract TResult Accept(_3E node, TContext context);
            protected internal abstract TResult Accept(_3F node, TContext context);
            protected internal abstract TResult Accept(_40 node, TContext context);
            protected internal abstract TResult Accept(_41 node, TContext context);
            protected internal abstract TResult Accept(_42 node, TContext context);
            protected internal abstract TResult Accept(_43 node, TContext context);
            protected internal abstract TResult Accept(_44 node, TContext context);
            protected internal abstract TResult Accept(_45 node, TContext context);
            protected internal abstract TResult Accept(_46 node, TContext context);
            protected internal abstract TResult Accept(_47 node, TContext context);
            protected internal abstract TResult Accept(_48 node, TContext context);
            protected internal abstract TResult Accept(_49 node, TContext context);
            protected internal abstract TResult Accept(_4A node, TContext context);
            protected internal abstract TResult Accept(_4B node, TContext context);
            protected internal abstract TResult Accept(_4C node, TContext context);
            protected internal abstract TResult Accept(_4D node, TContext context);
            protected internal abstract TResult Accept(_4E node, TContext context);
            protected internal abstract TResult Accept(_4F node, TContext context);
            protected internal abstract TResult Accept(_50 node, TContext context);
            protected internal abstract TResult Accept(_51 node, TContext context);
            protected internal abstract TResult Accept(_52 node, TContext context);
            protected internal abstract TResult Accept(_53 node, TContext context);
            protected internal abstract TResult Accept(_54 node, TContext context);
            protected internal abstract TResult Accept(_55 node, TContext context);
            protected internal abstract TResult Accept(_56 node, TContext context);
            protected internal abstract TResult Accept(_57 node, TContext context);
            protected internal abstract TResult Accept(_58 node, TContext context);
            protected internal abstract TResult Accept(_59 node, TContext context);
            protected internal abstract TResult Accept(_5A node, TContext context);
            protected internal abstract TResult Accept(_5B node, TContext context);
            protected internal abstract TResult Accept(_5C node, TContext context);
            protected internal abstract TResult Accept(_5D node, TContext context);
            protected internal abstract TResult Accept(_5E node, TContext context);
            protected internal abstract TResult Accept(_5F node, TContext context);
            protected internal abstract TResult Accept(_60 node, TContext context);
            protected internal abstract TResult Accept(_61 node, TContext context);
            protected internal abstract TResult Accept(_62 node, TContext context);
            protected internal abstract TResult Accept(_63 node, TContext context);
            protected internal abstract TResult Accept(_64 node, TContext context);
            protected internal abstract TResult Accept(_65 node, TContext context);
            protected internal abstract TResult Accept(_66 node, TContext context);
            protected internal abstract TResult Accept(_67 node, TContext context);
            protected internal abstract TResult Accept(_68 node, TContext context);
            protected internal abstract TResult Accept(_69 node, TContext context);
            protected internal abstract TResult Accept(_6A node, TContext context);
            protected internal abstract TResult Accept(_6B node, TContext context);
            protected internal abstract TResult Accept(_6C node, TContext context);
            protected internal abstract TResult Accept(_6D node, TContext context);
            protected internal abstract TResult Accept(_6E node, TContext context);
            protected internal abstract TResult Accept(_6F node, TContext context);
            protected internal abstract TResult Accept(_70 node, TContext context);
            protected internal abstract TResult Accept(_71 node, TContext context);
            protected internal abstract TResult Accept(_72 node, TContext context);
            protected internal abstract TResult Accept(_73 node, TContext context);
            protected internal abstract TResult Accept(_74 node, TContext context);
            protected internal abstract TResult Accept(_75 node, TContext context);
            protected internal abstract TResult Accept(_76 node, TContext context);
            protected internal abstract TResult Accept(_77 node, TContext context);
            protected internal abstract TResult Accept(_78 node, TContext context);
            protected internal abstract TResult Accept(_79 node, TContext context);
            protected internal abstract TResult Accept(_7A node, TContext context);
            protected internal abstract TResult Accept(_7B node, TContext context);
            protected internal abstract TResult Accept(_7C node, TContext context);
            protected internal abstract TResult Accept(_7D node, TContext context);
            protected internal abstract TResult Accept(_7E node, TContext context);
            protected internal abstract TResult Accept(_7F node, TContext context);
        }
        
        public sealed class _01 : _Ⰳx01ⲻ7FRealized
        {
            private _01(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._01>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._01> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._01> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._01>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._01>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._01(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._01>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _02 : _Ⰳx01ⲻ7FRealized
        {
            private _02(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._02>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._02> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._02> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._02>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._02>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._02(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._02>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _03 : _Ⰳx01ⲻ7FRealized
        {
            private _03(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._03>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._03> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._03> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._03>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._03>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._03(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._03>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _04 : _Ⰳx01ⲻ7FRealized
        {
            private _04(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._04>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._04> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._04> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._04>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._04>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._04(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._04>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _05 : _Ⰳx01ⲻ7FRealized
        {
            private _05(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._05>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._05> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._05> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._05>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._05>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._05(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._05>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _06 : _Ⰳx01ⲻ7FRealized
        {
            private _06(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._06>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._06> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._06> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._06>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._06>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._06(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._06>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _07 : _Ⰳx01ⲻ7FRealized
        {
            private _07(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._07>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._07> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._07> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._07>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._07>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._07(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._07>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _08 : _Ⰳx01ⲻ7FRealized
        {
            private _08(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._08>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._08> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._08> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._08>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._08>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._08(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._08>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _09 : _Ⰳx01ⲻ7FRealized
        {
            private _09(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._09>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._09> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._09> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._09>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._09>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._09(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._09>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0A : _Ⰳx01ⲻ7FRealized
        {
            private _0A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._0A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0B : _Ⰳx01ⲻ7FRealized
        {
            private _0B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._0B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0C : _Ⰳx01ⲻ7FRealized
        {
            private _0C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._0C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0D : _Ⰳx01ⲻ7FRealized
        {
            private _0D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._0D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0E : _Ⰳx01ⲻ7FRealized
        {
            private _0E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._0E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _0F : _Ⰳx01ⲻ7FRealized
        {
            private _0F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._0F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._0F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._0F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _10 : _Ⰳx01ⲻ7FRealized
        {
            private _10(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._10>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._10> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._10> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._10>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._10>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._10(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._10>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _11 : _Ⰳx01ⲻ7FRealized
        {
            private _11(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._11>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._11> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._11> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._11>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._11>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._11(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._11>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _12 : _Ⰳx01ⲻ7FRealized
        {
            private _12(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._12>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._12> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._12> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._12>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._12>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._12(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._12>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _13 : _Ⰳx01ⲻ7FRealized
        {
            private _13(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._13>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._13> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._13> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._13>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._13>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._13(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._13>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _14 : _Ⰳx01ⲻ7FRealized
        {
            private _14(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._14>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._14> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._14> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._14>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._14>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._14(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._14>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _15 : _Ⰳx01ⲻ7FRealized
        {
            private _15(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._15>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._15> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._15> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._15>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._15>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._15(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._15>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _16 : _Ⰳx01ⲻ7FRealized
        {
            private _16(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._16>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._16> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._16> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._16>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._16>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._16(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._16>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _17 : _Ⰳx01ⲻ7FRealized
        {
            private _17(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._17>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._17> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._17> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._17>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._17>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._17(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._17>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _18 : _Ⰳx01ⲻ7FRealized
        {
            private _18(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._18>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._18> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._18> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._18>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._18>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._18(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._18>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _19 : _Ⰳx01ⲻ7FRealized
        {
            private _19(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._19>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._19> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._19> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._19>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._19>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._19(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._19>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1A : _Ⰳx01ⲻ7FRealized
        {
            private _1A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._1A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1B : _Ⰳx01ⲻ7FRealized
        {
            private _1B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._1B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1C : _Ⰳx01ⲻ7FRealized
        {
            private _1C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._1C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1D : _Ⰳx01ⲻ7FRealized
        {
            private _1D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._1D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1E : _Ⰳx01ⲻ7FRealized
        {
            private _1E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._1E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _1F : _Ⰳx01ⲻ7FRealized
        {
            private _1F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._1F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._1F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._1F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _20 : _Ⰳx01ⲻ7FRealized
        {
            private _20(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._20>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._20> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._20> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._20>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._20>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._20(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._20>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _21 : _Ⰳx01ⲻ7FRealized
        {
            private _21(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._21>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._21> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._21> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._21>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._21>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._21(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._21>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _22 : _Ⰳx01ⲻ7FRealized
        {
            private _22(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._22>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._22> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._22> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._22>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._22>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._22(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._22>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _23 : _Ⰳx01ⲻ7FRealized
        {
            private _23(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._23>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._23> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._23> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._23>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._23>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._23(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._23>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _24 : _Ⰳx01ⲻ7FRealized
        {
            private _24(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._24>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._24> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._24> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._24>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._24>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._24(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._24>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _25 : _Ⰳx01ⲻ7FRealized
        {
            private _25(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._25>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._25> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._25> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._25>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._25>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._25(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._25>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _26 : _Ⰳx01ⲻ7FRealized
        {
            private _26(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._26>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._26> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._26> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._26>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._26>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._26(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._26>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _27 : _Ⰳx01ⲻ7FRealized
        {
            private _27(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._27>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._27> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._27> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._27>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._27>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._27(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._27>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _28 : _Ⰳx01ⲻ7FRealized
        {
            private _28(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._28>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._28> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._28> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._28>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._28>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._28(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._28>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _29 : _Ⰳx01ⲻ7FRealized
        {
            private _29(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._29>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._29> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._29> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._29>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._29>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._29(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._29>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2A : _Ⰳx01ⲻ7FRealized
        {
            private _2A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._2A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2B : _Ⰳx01ⲻ7FRealized
        {
            private _2B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._2B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2C : _Ⰳx01ⲻ7FRealized
        {
            private _2C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._2C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2D : _Ⰳx01ⲻ7FRealized
        {
            private _2D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._2D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2E : _Ⰳx01ⲻ7FRealized
        {
            private _2E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._2E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _2F : _Ⰳx01ⲻ7FRealized
        {
            private _2F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._2F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._2F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._2F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _30 : _Ⰳx01ⲻ7FRealized
        {
            private _30(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._30>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._30> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._30> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._30>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._30>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._30(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._30>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _31 : _Ⰳx01ⲻ7FRealized
        {
            private _31(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._31>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._31> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._31> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._31>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._31>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._31(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._31>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _32 : _Ⰳx01ⲻ7FRealized
        {
            private _32(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._32>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._32> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._32> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._32>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._32>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._32(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._32>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _33 : _Ⰳx01ⲻ7FRealized
        {
            private _33(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._33>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._33> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._33> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._33>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._33>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._33(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._33>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _34 : _Ⰳx01ⲻ7FRealized
        {
            private _34(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._34>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._34> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._34> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._34>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._34>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._34(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._34>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _35 : _Ⰳx01ⲻ7FRealized
        {
            private _35(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._35>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._35> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._35> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._35>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._35>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._35(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._35>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _36 : _Ⰳx01ⲻ7FRealized
        {
            private _36(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._36>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._36> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._36> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._36>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._36>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._36(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._36>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _37 : _Ⰳx01ⲻ7FRealized
        {
            private _37(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._37>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._37> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._37> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._37>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._37>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._37(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._37>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _38 : _Ⰳx01ⲻ7FRealized
        {
            private _38(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._38>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._38> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._38> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._38>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._38>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._38(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._38>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _39 : _Ⰳx01ⲻ7FRealized
        {
            private _39(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._39>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._39> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._39> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._39>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._39>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._39(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._39>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3A : _Ⰳx01ⲻ7FRealized
        {
            private _3A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._3A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3B : _Ⰳx01ⲻ7FRealized
        {
            private _3B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._3B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3C : _Ⰳx01ⲻ7FRealized
        {
            private _3C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._3C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3D : _Ⰳx01ⲻ7FRealized
        {
            private _3D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._3D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3E : _Ⰳx01ⲻ7FRealized
        {
            private _3E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._3E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _3F : _Ⰳx01ⲻ7FRealized
        {
            private _3F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._3F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._3F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._3F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _40 : _Ⰳx01ⲻ7FRealized
        {
            private _40(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._40>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._40> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._40> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._40>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._40>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._40(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._40>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _41 : _Ⰳx01ⲻ7FRealized
        {
            private _41(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._41>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._41> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._41> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._41>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._41>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._41(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._41>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _42 : _Ⰳx01ⲻ7FRealized
        {
            private _42(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._42>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._42> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._42> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._42>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._42>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._42(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._42>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _43 : _Ⰳx01ⲻ7FRealized
        {
            private _43(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._43>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._43> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._43> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._43>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._43>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._43(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._43>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _44 : _Ⰳx01ⲻ7FRealized
        {
            private _44(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._44>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._44> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._44> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._44>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._44>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._44(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._44>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _45 : _Ⰳx01ⲻ7FRealized
        {
            private _45(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._45>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._45> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._45> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._45>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._45>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._45(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._45>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _46 : _Ⰳx01ⲻ7FRealized
        {
            private _46(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._46>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._46> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._46> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._46>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._46>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._46(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._46>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _47 : _Ⰳx01ⲻ7FRealized
        {
            private _47(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._47>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._47> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._47> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._47>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._47>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._47(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._47>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _48 : _Ⰳx01ⲻ7FRealized
        {
            private _48(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._48>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._48> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._48> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._48>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._48>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._48(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._48>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _49 : _Ⰳx01ⲻ7FRealized
        {
            private _49(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._49>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._49> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._49> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._49>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._49>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._49(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._49>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4A : _Ⰳx01ⲻ7FRealized
        {
            private _4A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._4A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4B : _Ⰳx01ⲻ7FRealized
        {
            private _4B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._4B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4C : _Ⰳx01ⲻ7FRealized
        {
            private _4C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._4C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4D : _Ⰳx01ⲻ7FRealized
        {
            private _4D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._4D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4E : _Ⰳx01ⲻ7FRealized
        {
            private _4E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._4E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _4F : _Ⰳx01ⲻ7FRealized
        {
            private _4F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._4F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._4F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._4F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _50 : _Ⰳx01ⲻ7FRealized
        {
            private _50(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._50>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._50> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._50> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._50>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._50>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._50(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._50>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _51 : _Ⰳx01ⲻ7FRealized
        {
            private _51(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._51>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._51> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._51> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._51>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._51>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._51(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._51>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _52 : _Ⰳx01ⲻ7FRealized
        {
            private _52(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._52>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._52> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._52> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._52>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._52>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._52(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._52>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _53 : _Ⰳx01ⲻ7FRealized
        {
            private _53(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._53>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._53> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._53> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._53>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._53>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._53(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._53>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _54 : _Ⰳx01ⲻ7FRealized
        {
            private _54(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._54>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._54> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._54> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._54>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._54>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._54(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._54>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _55 : _Ⰳx01ⲻ7FRealized
        {
            private _55(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._55>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._55> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._55> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._55>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._55>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._55(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._55>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _56 : _Ⰳx01ⲻ7FRealized
        {
            private _56(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._56>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._56> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._56> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._56>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._56>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._56(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._56>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _57 : _Ⰳx01ⲻ7FRealized
        {
            private _57(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._57>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._57> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._57> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._57>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._57>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._57(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._57>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _58 : _Ⰳx01ⲻ7FRealized
        {
            private _58(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._58>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._58> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._58> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._58>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._58>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._58(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._58>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _59 : _Ⰳx01ⲻ7FRealized
        {
            private _59(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._59>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._59> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._59> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._59>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._59>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._59(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._59>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5A : _Ⰳx01ⲻ7FRealized
        {
            private _5A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._5A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5B : _Ⰳx01ⲻ7FRealized
        {
            private _5B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._5B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5C : _Ⰳx01ⲻ7FRealized
        {
            private _5C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._5C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5D : _Ⰳx01ⲻ7FRealized
        {
            private _5D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._5D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5E : _Ⰳx01ⲻ7FRealized
        {
            private _5E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._5E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _5F : _Ⰳx01ⲻ7FRealized
        {
            private _5F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._5F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._5F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._5F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _60 : _Ⰳx01ⲻ7FRealized
        {
            private _60(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._60>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._60> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._60> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._60>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._60>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._60(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._60>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _61 : _Ⰳx01ⲻ7FRealized
        {
            private _61(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._61>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._61> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._61> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._61>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._61>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._61(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._61>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _62 : _Ⰳx01ⲻ7FRealized
        {
            private _62(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._62>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._62> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._62> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._62>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._62>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._62(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._62>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _63 : _Ⰳx01ⲻ7FRealized
        {
            private _63(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._63>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._63> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._63> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._63>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._63>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._63(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._63>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _64 : _Ⰳx01ⲻ7FRealized
        {
            private _64(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._64>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._64> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._64> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._64>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._64>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._64(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._64>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _65 : _Ⰳx01ⲻ7FRealized
        {
            private _65(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._65>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._65> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._65> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._65>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._65>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._65(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._65>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _66 : _Ⰳx01ⲻ7FRealized
        {
            private _66(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._66>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._66> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._66> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._66>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._66>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._66(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._66>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _67 : _Ⰳx01ⲻ7FRealized
        {
            private _67(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._67>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._67> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._67> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._67>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._67>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._67(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._67>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _68 : _Ⰳx01ⲻ7FRealized
        {
            private _68(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._68>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._68> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._68> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._68>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._68>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._68(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._68>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _69 : _Ⰳx01ⲻ7FRealized
        {
            private _69(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._69>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._69> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._69> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._69>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._69>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._69(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._69>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6A : _Ⰳx01ⲻ7FRealized
        {
            private _6A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._6A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6B : _Ⰳx01ⲻ7FRealized
        {
            private _6B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._6B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6C : _Ⰳx01ⲻ7FRealized
        {
            private _6C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._6C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6D : _Ⰳx01ⲻ7FRealized
        {
            private _6D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._6D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6E : _Ⰳx01ⲻ7FRealized
        {
            private _6E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._6E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _6F : _Ⰳx01ⲻ7FRealized
        {
            private _6F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._6F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._6F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._6F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _70 : _Ⰳx01ⲻ7FRealized
        {
            private _70(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._70>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._70> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._70> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._70>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._70>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._70(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._70>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _71 : _Ⰳx01ⲻ7FRealized
        {
            private _71(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._71>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._71> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._71> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._71>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._71>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._71(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._71>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _72 : _Ⰳx01ⲻ7FRealized
        {
            private _72(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._72>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._72> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._72> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._72>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._72>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._72(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._72>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _73 : _Ⰳx01ⲻ7FRealized
        {
            private _73(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._73>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._73> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._73> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._73>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._73>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._73(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._73>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _74 : _Ⰳx01ⲻ7FRealized
        {
            private _74(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._74>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._74> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._74> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._74>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._74>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._74(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._74>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _75 : _Ⰳx01ⲻ7FRealized
        {
            private _75(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._75>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._75> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._75> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._75>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._75>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._75(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._75>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _76 : _Ⰳx01ⲻ7FRealized
        {
            private _76(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._76>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._76> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._76> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._76>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._76>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._76(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._76>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _77 : _Ⰳx01ⲻ7FRealized
        {
            private _77(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._77>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._77> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._77> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._77>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._77>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._77(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._77>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _78 : _Ⰳx01ⲻ7FRealized
        {
            private _78(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._78>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._78> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._78> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._78>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._78>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._78(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._78>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _79 : _Ⰳx01ⲻ7FRealized
        {
            private _79(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._79>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._79> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._79> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._79>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._79>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._79(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._79>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7A : _Ⰳx01ⲻ7FRealized
        {
            private _7A(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7A>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7A> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7A> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7A>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7A>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._7A(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7A>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7B : _Ⰳx01ⲻ7FRealized
        {
            private _7B(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7B>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7B> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7B> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7B>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7B>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._7B(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7B>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7C : _Ⰳx01ⲻ7FRealized
        {
            private _7C(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7C>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7C> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7C> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7C>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7C>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._7C(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7C>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7D : _Ⰳx01ⲻ7FRealized
        {
            private _7D(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7D>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7D> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7D> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7D>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7D>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._7D(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7D>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7E : _Ⰳx01ⲻ7FRealized
        {
            private _7E(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7E>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7E> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7E> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7E>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7E>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._7E(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7E>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
        
        public sealed class _7F : _Ⰳx01ⲻ7FRealized
        {
            private _7F(ITokenStream<char>? nextTokens)
            {
                this.RealizationResult = new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7F>(true, this, nextTokens);
            }
            
            private IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7F> RealizationResult { get; }
            
            public static IRealizationResult<char, _Ⰳx01ⲻ7FRealized._7F> Create(IFuture<IRealizationResult<char>> previousNodeRealizationResult)
            {
                var output = previousNodeRealizationResult.Value;
if (!output.Success)
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7F>(false, default, output.RemainingTokens);
}

var input = output.RemainingTokens;
if (input == null)
{
    //// TODO realizationresult.create would be nice
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7F>(false, default, input);
}

if (input.Current == 'A') //// TODO do this correctly...du's aren't always terminal nodes, and they aren't even terminal nodes in your case
{
    var a = new _Ⰳx01ⲻ7FRealized._7F(input.Next());
    return a.RealizationResult;
}
else
{
    return new RealizationResult<char, _Ⰳx01ⲻ7FRealized._7F>(false, default, input);
}
            }
            
            public override _Ⰳx01ⲻ7FDeferred Convert()
            {
                return new _Ⰳx01ⲻ7FDeferred(Future.Create(() => this.RealizationResult));
            }
            
            protected override TResult Dispatch<TResult, TContext>(Visitor<TResult, TContext> visitor, TContext context)
            {
                return visitor.Accept(this, context);
            }
        }
    }
    
}
