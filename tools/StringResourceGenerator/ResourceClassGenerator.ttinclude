<#
//---------------------------------------------------------------------
// <copyright file="ResourceClassGenerator.ttinclude" company="Microsoft">
//      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------
#>
<#@ template debug="true" hostspecific="true" language="C#" visibility="internal" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ Import Namespace="System" #>
<#@ Import Namespace="System.Diagnostics" #>
<#@ Import Namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="ClassGeneratorCommon.ttinclude" #>
<#
    // ************************************************************************
    // Step 1: Validate the input arguments.
    // ************************************************************************
    if (string.IsNullOrEmpty(Configuration.ResourceClassNamespace))
    {
        throw new ArgumentException("Invalid ResourceClassNamespace");
    }

    if (string.IsNullOrEmpty(Configuration.AssemblyName))
    {
        throw new ArgumentException("Invalid AssemblyName");
    }

    if (string.IsNullOrEmpty(Configuration.ResourceClassName))
    {
        throw new ArgumentException("Invalid ResourceClassName");
    }
#>
<#
    // ************************************************************************
    // Step 2: Generate document header and common imports.
    // ************************************************************************
#>
//---------------------------------------------------------------------
// <copyright file="<#= Path.GetFileNameWithoutExtension(this.Host.TemplateFile) #>.cs" company="Microsoft">
//      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
//
//      GENERATED FILE.  DO NOT MODIFY.
//
// </copyright>
//---------------------------------------------------------------------

namespace <#= Configuration.ResourceClassNamespace #> {
    using System;
    using System.Globalization;
    using System.Reflection;
    using System.Resources;
#if !PORTABLELIB
    using System.Security.Permissions;
#endif
    using System.Text;
    using System.Threading;

<#
    // ************************************************************************
    // Step 3: Generate string resource attributes if not SkipSRAttributes.
    // ************************************************************************
    if (!Configuration.SkipSRAttributes)
    {
#>
    using System.ComponentModel;
#if !PORTABLELIB
    [AttributeUsage(AttributeTargets.All)]
    internal sealed class <#= Configuration.ResourceClassName #>DescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <summary>
        ///     Constructs a new sys description.
        /// </summary>
        /// <param name='description'>
        ///     description text.
        /// </param>
        public <#= Configuration.ResourceClassName #>DescriptionAttribute(string description) : base(description) {
        }

        /// <summary>
        ///     Retrieves the description text.
        /// </summary>
        /// <returns>
        ///     description
        /// </returns>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = <#= Configuration.ResourceClassName #>.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }

    [AttributeUsage(AttributeTargets.All)]
    internal sealed class <#= Configuration.ResourceClassName #>CategoryAttribute : CategoryAttribute {

        public <#= Configuration.ResourceClassName #>CategoryAttribute(string category) : base(category) {
        }

        protected override string GetLocalizedString(string value) {
            return <#= Configuration.ResourceClassName #>.GetString(value);
        }
    }
#endif

<#
    }
#>
<#
    // ************************************************************************
    // Step 4: Generate resource class header.
    // ************************************************************************
#>
    /// <summary>
    ///    AutoGenerated resource class. Usage:
    ///
    ///        string s = <#= Configuration.ResourceClassName #>.GetString(<#= Configuration.ResourceClassName #>.MyIdenfitier);
    /// </summary>
    internal sealed class <#= Configuration.ResourceClassName #> {
<#
    // ************************************************************************
    // Step 5: Generate a string const for each string resource item.
    // ************************************************************************
    GenerateFromAllTextFiles();
#>
<#
    // ************************************************************************
    // Step 6: Generate resource class footer
    // ************************************************************************
#>

        static <#= Configuration.ResourceClassName #> loader = null;
        ResourceManager resources;

        internal <#= Configuration.ResourceClassName #>() {
#if !PORTABLELIB
            resources = new System.Resources.ResourceManager("<#= Configuration.AssemblyName #>", this.GetType().Assembly);
#else
            resources = new System.Resources.ResourceManager("<#= Configuration.AssemblyName #>", this.GetType().GetTypeInfo().Assembly);
#endif
        }

        private static <#= Configuration.ResourceClassName #> GetLoader() {
            if (loader == null) {
                <#= Configuration.ResourceClassName #> sr = new <#= Configuration.ResourceClassName #>();
                Interlocked.CompareExchange(ref loader, sr, null);
            }
            return loader;
        }

        private static CultureInfo Culture {
            get { return null/*use ResourceManager default, CultureInfo.CurrentUICulture*/; }
        }

        public static ResourceManager Resources {
            get {
                return GetLoader().resources;
            }
        }

        public static string GetString(string name, params object[] args) {
            <#= Configuration.ResourceClassName #> sys = GetLoader();
            if (sys == null)
                return null;
            string res = sys.resources.GetString(name, <#= Configuration.ResourceClassName #>.Culture);

            if (args != null && args.Length > 0) {
                for (int i = 0; i < args.Length; i ++) {
                    String value = args[i] as String;
                    if (value != null && value.Length > 1024) {
                        args[i] = value.Substring(0, 1024 - 3) + "...";
                    }
                }
                return String.Format(CultureInfo.CurrentCulture, res, args);
            }
            else {
                return res;
            }
        }

        public static string GetString(string name) {
            <#= Configuration.ResourceClassName #> sys = GetLoader();
            if (sys == null)
                return null;
            return sys.resources.GetString(name, <#= Configuration.ResourceClassName #>.Culture);
        }

        public static string GetString(string name, out bool usedFallback) {
            // always false for this version of gensr
            usedFallback = false;
            return GetString(name);
        }
#if !PORTABLELIB
        public static object GetObject(string name) {
            <#= Configuration.ResourceClassName #> sys = GetLoader();
            if (sys == null)
                return null;
            return sys.resources.GetObject(name, <#= Configuration.ResourceClassName #>.Culture);
        }
#endif
    }
}<#+
    // ************************************************************************
    // Generation helper method
    // ************************************************************************
    private void GenerateFromSingleResource(string id, string content)
    {
#>
        internal const string <#= id #> = "<#= id #>";
<#+
    }
#>