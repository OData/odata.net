<#
//---------------------------------------------------------------------
// <copyright file="StringsClassGenerator.ttinclude" company="Microsoft">
//      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
// </copyright>
//---------------------------------------------------------------------
#>
<#@ template debug="true" hostspecific="true" language="C#" visibility="internal" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ Import Namespace="System" #>
<#@ Import Namespace="System.Diagnostics" #>
<#@ Import Namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="ClassGeneratorCommon.ttinclude" #>
<#
    // ************************************************************************
    // Step 1: Validate the input arguments.
    // ************************************************************************
    if (string.IsNullOrEmpty(Configuration.ResourceClassNamespace))
    {
        throw new ArgumentException("Invalid ResourceClassNamespace");
    }

    if (string.IsNullOrEmpty(Configuration.AssemblyName))
    {
        throw new ArgumentException("Invalid AssemblyName");
    }

    if (string.IsNullOrEmpty(Configuration.ResourceClassName))
    {
        throw new ArgumentException("Invalid ResourceClassName");
    }
#>
<#
    // ************************************************************************
    // Step 2: Generate document header and common imports.
    // ************************************************************************
#>
// <auto-generated/>

//---------------------------------------------------------------------
// <copyright file="<#= Path.GetFileNameWithoutExtension(this.Host.TemplateFile) #>.cs" company="Microsoft">
//      Copyright (C) Microsoft Corporation. All rights reserved. See License.txt in the project root for license information.
//
//      GENERATED FILE.  DO NOT MODIFY.
//
// </copyright>
//---------------------------------------------------------------------

namespace <#= Configuration.ResourceClassNamespace #> {
    using System;
    using System.Resources;

<#
    // ************************************************************************
    // Step 3: Generate resource class header.
    // ************************************************************************
#>
    /// <summary>
    ///    Strongly-typed and parameterized string resources.
    /// </summary>
    internal static class Strings {
<#
    // ************************************************************************
    // Step 4: Generate a string const for each string resource item.
    // ************************************************************************
    GenerateFromAllTextFiles();
#>
<#
    // ************************************************************************
    // Step 5: Generate resource class footer
    // ************************************************************************
#>
    }

    /// <summary>
    ///    Strongly-typed and parameterized exception factory.
    /// </summary>
    internal static partial class Error {

        /// <summary>
        /// The exception that is thrown when a null reference (Nothing in Visual Basic) is passed to a method that does not accept it as a valid argument.
        /// </summary>
        internal static Exception ArgumentNull(string paramName) {
            return new ArgumentNullException(paramName);
        }

        /// <summary>
        /// The exception that is thrown when the value of an argument is outside the allowable range of values as defined by the invoked method.
        /// </summary>
        internal static Exception ArgumentOutOfRange(string paramName) {
            return new ArgumentOutOfRangeException(paramName);
        }

        /// <summary>
        /// The exception that is thrown when the author has not yet implemented the logic at this point in the program. This can act as an exception based TODO tag.
        /// </summary>
        internal static Exception NotImplemented() {
            return new NotImplementedException();
        }

        /// <summary>
        /// The exception that is thrown when an invoked method is not supported, or when there is an attempt to read, seek, or write to a stream that does not support the invoked functionality.
        /// </summary>
        internal static Exception NotSupported() {
            return new NotSupportedException();
        }
    }
}<#+
    // ************************************************************************
    // Generation helper methods
    // ************************************************************************
    private static int ComputeArgumentCountInFormatString(string str)
    {
        bool parsingIndex = false;
        int maxCount = 0;
        var literal = new StringBuilder();
        foreach (char c in str)
        {
            if (parsingIndex)
            {
                if (char.IsDigit(c))
                {
                    literal.Append(c);
                }
                else
                {
                    // Support handling the following three cases:
                    //   "{2}"
                    //   "{0,8:c}"
                    //   "{1:p1}"
                    if (c == '}' || c == ',' || c == ':')
                    {
                        int count = int.Parse(literal.ToString()) + 1;
                        if (count > maxCount)
                        {
                            maxCount = count;
                        }

                        literal.Clear();
                    }

                    parsingIndex = false;
                }
            }
            else
            {
                parsingIndex = c == '{';
            }
        }

        return maxCount;
    }

    private string GenerateParameterList(int count)
    {
        var builder = new StringBuilder();

        for (int i = 0; i < count; ++i)
        {
            builder.AppendFormat("object p{0}", i);

            if (i != count - 1)
            {
                builder.Append(", ");
            }
        }

        return builder.ToString();
    }

    private string GenerateArgumentList(int count)
    {
        var builder = new StringBuilder();

        for (int i = 0; i < count; ++i)
        {
            builder.AppendFormat("p{0}", i);

            if (i != count - 1)
            {
                builder.Append(", ");
            }
        }

        return builder.ToString();
    }

    private void GenerateFromSingleResource(string id, string content)
    {
        int count = ComputeArgumentCountInFormatString(content);
#>
        /// <summary>
        /// A string like "<#= content.Replace("<", "&lt;").Replace(">", "&gt;") #>"
        /// </summary>
<#+
        if (count == 0)
        {
            GenerateAsProperty(id);
        }
        else
        {
            GenerateAsMethod(id, count);
        }
    }

    private void GenerateAsProperty(string id)
    {
#>
        internal static string <#= id #>
        {
            get
            {
                return <#= Configuration.ResourceClassNamespace #>.<#= Configuration.ResourceClassName #>.GetString(<#= Configuration.ResourceClassNamespace #>.<#= Configuration.ResourceClassName #>.<#= id #>);
            }
        }

<#+
    }

    private void GenerateAsMethod(string id, int count)
    {
#>
        internal static string <#= id #>(<#= GenerateParameterList(count) #>)
        {
            return <#= Configuration.ResourceClassNamespace #>.<#= Configuration.ResourceClassName #>.GetString(<#= Configuration.ResourceClassNamespace #>.<#= Configuration.ResourceClassName #>.<#= id #>, <#= GenerateArgumentList(count) #>);
        }

<#+
    }
#>